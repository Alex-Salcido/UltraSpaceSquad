<!DOCTYPE html>
<html lang="en">
<head>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-22GVPJFMS0"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-22GVPJFMS0');
    </script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ultra Hyper Radical Space Squadron</title>
    <link href="https://fonts.googleapis.com/css2?family=Bebas+Neue&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400&display=swap" rel="stylesheet">
    <style>
        body { margin: 0; overflow: hidden; background: #000; }
        #mainMenu {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            font-family: 'Roboto', Arial, sans-serif;
            z-index: 10;
        }
        #mainMenu h1 {
            font-family: 'Bebas Neue', sans-serif;
            font-size: 60px;
            margin: 0;
            line-height: 1;
            text-align: center;
        }
        #mainMenu input {
            padding: 10px;
            font-size: 18px;
            margin: 10px 0;
            width: 200px;
            font-family: 'Roboto', sans-serif;
        }
        #mainMenu button {
            padding: 10px 20px;
            font-size: 18px;
            cursor: pointer;
            font-family: 'Roboto', sans-serif;
        }
        #mainMenu p {
            color: red;
            margin: 10px 0;
            font-family: 'Roboto', sans-serif;
        }
        #mainMenu .description, #mainMenu .controls, #mainMenu .power-ups {
            font-size: 12px;
            margin: 5px 0;
            text-align: center;
            max-width: 400px;
        }
        #mainMenu .controls strong, #mainMenu .power-ups strong {
            color: cyan;
        }
        #mainMenu .sponsor {
            position: absolute;
            bottom: 20px;
            font-size: 20px;
            font-family: 'Bebas Neue', sans-serif;
        }
        #mainMenu .sponsor a {
            color: #00ffff;
            text-decoration: none;
        }
        #mainMenu .sponsor a:hover {
            text-decoration: underline;
        }
        #mainMenu .credit {
            font-size: 14px;
            font-family: 'Roboto', sans-serif;
            margin: 5px 0;
        }
        #mainMenu .credit a.author {
            color: #00ffff;
            text-decoration: none;
        }
        #mainMenu .credit a.author:hover {
            text-decoration: underline;
        }
        #mainMenu .credit span {
            color: white;
        }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-family: Arial;
            display: flex;
            align-items: center;
            margin-bottom: 20px;
        }
        #scoreDisplay { 
            margin-right: 30px;
        }
        #livesDisplay { 
            display: flex; 
            align-items: center;
            margin-left: 20px;
        }
        .heart {
            width: 20px;
            height: 20px;
            background: red;
            position: relative;
            margin-right: 15px;
            transform: rotate(-45deg);
        }
        .heart:before,
        .heart:after {
            content: '';
            width: 20px;
            height: 20px;
            background: red;
            border-radius: 50%;
            position: absolute;
        }
        .heart:before {
            top: -10px;
            left: 0;
        }
        .heart:after {
            left: 10px;
            top: 0;
        }
        #bars {
            position: absolute;
            top: 40px;
            left: 10px;
            color: white;
            font-family: Arial;
        }
        .bar-label { margin-bottom: 5px; }
        .bar-container {
            width: 100px;
            height: 10px;
            background: #333;
            border: 1px solid #fff;
            position: relative;
        }
        .bar-fill {
            height: 100%;
            transition: width 0.1s;
        }
        #brakeBarFill { background: yellow; }
        #boostBarFill { background: blue; }
        #powerUpMessage {
            position: absolute;
            top: 70px;
            left: 10px;
            color: yellow;
            font-family: Arial;
            font-size: 20px;
        }
        #crosshair {
            position: absolute;
            width: 20px;
            height: 20px;
            background: transparent;
            border: 2px solid cyan;
            border-radius: 50%;
            pointer-events: none;
            transform: translate(-50%, -50%);
        }
        #outerCrosshair {
            position: absolute;
            width: 30px;
            height: 30px;
            background: transparent;
            border: 2px solid rgba(0, 255, 255, 0.5);
            border-radius: 50%;
            pointer-events: none;
            transform: translate(-50%, -50%);
        }
        canvas { cursor: none; }
        .name-tag {
            position: absolute;
            color: white;
            font-family: Arial;
            font-size: 12px;
            background: rgba(0, 0, 0, 0.5);
            padding: 2px 5px;
            border-radius: 3px;
            pointer-events: none;
        }
        #gameOverMenu {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            font-family: Arial, sans-serif;
            z-index: 10;
        }
        #gameOverMenu h2 {
            font-size: 46px;
            margin-bottom: 20px;
            font-family: 'Bebas Neue', sans-serif;
        }
        #gameOverMenu button {
            padding: 10px 20px;
            font-size: 18px;
            cursor: pointer;
        }
        /* Joystick styles */
        #movementJoystick, #aimJoystick {
            position: absolute;
            bottom: 20px;
            width: 100px;
            height: 100px;
            z-index: 11; /* Above game elements */
            display: none; /* Hidden by default */
        }
        #movementJoystick { left: 20px; }
        #aimJoystick { right: 20px; }
        @media (max-width: 480px) and (pointer: coarse) { /* Mobile with touch */
            #movementJoystick, #aimJoystick {
                display: block; /* Show on mobile */
            }
            #movementJoystick, #aimJoystick {
                width: 80px;
                height: 80px; /* Smaller on tiny screens */
            }
        }
    </style>
</head>
<body>
    <div id="mainMenu">
        <h1>Ultra Hyper Radical<br>Space Squadron</h1>
        <div class="credit">
            by <a href="https://x.com/AlexerSalcido" target="_blank" class="author">Alex Salcido</a> <span>+ Grok3 + 3JS</span>
        </div>
        <div class="description">A free-to-play space shooter. v0.91</div>
        <input type="text" id="playerNameInput" placeholder="Enter your name">
        <button onclick="startGame()">Start Game</button>
        <p id="nameError"></p>
        <p id="highScoreDisplay"></p>
        <div class="controls">
            <strong>Controls:</strong><br>
            Mouse and keyboard:<br>
            Use WASD to move the spaceship<br>
            Use C to do an Aileron Roll and activate shield<br>
            Spacebar to boost<br>
            Move the mouse to aim<br>
            Left click to shoot<br>
            Right click to brake<br>
            <strong>Mobile:</strong><br>
            Left joystick to move<br>
            Right joystick to aim and shoot
        </div>
        <div class="power-ups">
            <strong>Power Ups:</strong><br>
            Hearts recover life<br>
            Yellow orbs upgrade your weapons
        </div>
        <div class="sponsor">
            <a href="https://x.com/AlexerSalcido/" target="_blank">Contact me and Become a Sponsor</a>
        </div>
    </div>
    <div id="info" style="display: none;">
        <span id="scoreDisplay">Score: <span id="score">0</span></span>
        <br><br>
        <div id="livesDisplay"></div>
    </div>
    <div id="bars" style="display: none;">
        <br><br>
        <div class="bar-label">Brake</div>
        <div class="bar-container">
            <div id="brakeBarFill" class="bar-fill" style="width: 100%;"></div>
        </div>
        <div class="bar-label">Boost</div>
        <div class="bar-container">
            <div id="boostBarFill" class="bar-fill" style="width: 100%;"></div>
        </div>
    </div>
    <div id="powerUpMessage" style="display: none;"></div>
    <div id="crosshair" style="display: none;"></div>
    <div id="outerCrosshair" style="display: none;"></div>
    <div id="gameOverMenu">
        <h2>Game Over!</h2>
        <p>Final Score: <span id="finalScore"></span></p>
        <button onclick="restartGame()">Start Again</button>
    </div>
    <!-- Joystick zones -->
    <div id="movementJoystick"></div>
    <div id="aimJoystick"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    <!-- Load Nipple.js -->
    <script src="https://cdn.jsdelivr.net/npm/nipplejs@0.10.0/dist/nipplejs.min.js"></script>
    <script>
        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Static background
        const textureLoader = new THREE.TextureLoader();
        textureLoader.load('textures/starfield.jpg', (texture) => {
            scene.background = texture;
        });

        // Toggle tags
        let showEnemyTags = false;

        // Track variables
        const trackLength = 1000;
        let trackPosition = 0;
        let baseTrackSpeed = 0.1;
        let currentTrackSpeed = baseTrackSpeed;

        // Spaceship
        const spaceshipGroup = new THREE.Group();
        const mainBodyGeometry = new THREE.ConeGeometry(0.5, 2, 3);
        const mainBodyMaterial = new THREE.MeshBasicMaterial({ color: 0xaaaaaa });
        const mainBody = new THREE.Mesh(mainBodyGeometry, mainBodyMaterial);
        mainBody.rotation.x = -Math.PI / 2;
        spaceshipGroup.add(mainBody);

        const wingGeometry = new THREE.BoxGeometry(2, 0.1, 0.5);
        const wingMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
        const leftWing = new THREE.Mesh(wingGeometry, wingMaterial);
        const rightWing = new THREE.Mesh(wingGeometry, wingMaterial);
        leftWing.position.set(-1.5, 0, 0);
        rightWing.position.set(1.5, 0, 0);
        leftWing.rotation.z = Math.PI / 4;
        rightWing.rotation.z = -Math.PI / 4;
        spaceshipGroup.add(leftWing, rightWing);

        const cockpitGeometry = new THREE.BoxGeometry(0.3, 0.2, 0.5);
        const cockpitMaterial = new THREE.MeshBasicMaterial({ color: 0x0000ff });
        const cockpit = new THREE.Mesh(cockpitGeometry, cockpitMaterial);
        cockpit.position.set(0, 0.3, -0.5);
        spaceshipGroup.add(cockpit);
        scene.add(spaceshipGroup);
        spaceshipGroup.position.z = -5;

        // Flying trails
        let leftTrail = null, rightTrail = null;
        function createTrails() {
            const trailMaterial = new THREE.LineBasicMaterial({ color: 0xffff00 });
            const trailGeometry = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, 2)]);
            leftTrail = new THREE.Line(trailGeometry, trailMaterial);
            rightTrail = new THREE.Line(trailGeometry, trailMaterial);
            leftTrail.position.set(-1.5, 0, 0);
            rightTrail.position.set(1.5, 0, 0);
            leftTrail.visible = false;
            rightTrail.visible = false;
            spaceshipGroup.add(leftTrail);
            spaceshipGroup.add(rightTrail);
        }
        createTrails();

        // Camera setup
        camera.position.set(0, 2, 5);
        camera.lookAt(0, 0, -100);

        // Camera shake variables
        let shakeTimer = 0;
        let shakeIntensity = 0;
        let boostShakeTimer = 0;
        let boostShakeIntensity = 0;

        // Limit zones for camera behavior
        const firstZoneLimit = 5;
        const secondZoneLimit = 9;

        // Game variables
        let score = 0;
        let lives = 3;
        let gameOver = false;
        let bossSpawned = false;
        let justRestarted = false;
        let invincibilityTimer = 0;
        let doubleShotActive = false;
        let doubleShotTimer = 0;
        let playerName = '';
        let highScore = localStorage.getItem('highScore') || 0;

        // Brake and Boost variables
        let brakeBar = 100;
        let boostBar = 100;
        let isBraking = false;
        let isBoosting = false;
        let brakeRegenDelay = 0;
        let boostRegenDelay = 0;

        // Roll variables
        let rollActive = false;
        let rollCooldown = 0;
        let rollAngle = 0;
        let rollDirection = 1;

        const projectiles = [];
        const enemyProjectiles = [];
        const explosionParticles = [];
        const enemies = [];
        const obstacles = [];
        const powerUps = [];
        const mountains = [];
        const billboards = [];
        const sideShips = [];

        // Boss change color
        let bossHitTimer = 0;
        let bossHitCount = 0;
        const bossOriginalColor = 0x0000ff;
        const bossHitColor = 0xff0000;

        // Sounds
        const enemyDestroySound = new Audio('');
        const playerHitSound = new Audio('');
        const powerUpSound = new Audio('');
        const playerDestroySound = new Audio('');
        const shootSound = new Audio('');
        const enemyAppearMusic = new Audio('');
        const bossDamageSound = new Audio('');
        const bossDestroySound = new Audio('');
        const backgroundMusic = new Audio('');
        backgroundMusic.loop = true;

        // Raycaster for mouse aiming
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let mouseWorldPos = new THREE.Vector3();

        // Crosshair setup
        const crosshair = document.getElementById('crosshair');
        const outerCrosshair = document.getElementById('outerCrosshair');
        let crosshairX = 0, crosshairY = 0;
        let outerCrosshairX = 0, outerCrosshairY = 0;

        // Joystick states
        let movementJoystickActive = false;
        let aimJoystickActive = false;
        let lastShotTime = 0; // Tracks last shot timestamp
        const shootCooldown = 0.2; // 0.5 seconds between shots on mobile

        // Movement and rotation controls
        const keys = { w: false, a: false, s: false, d: false, space: false, q: false, e: false, c: false };
        document.addEventListener('keydown', (event) => {
            if (event.key === 'w') keys.w = true;
            if (event.key === 'a') keys.a = true;
            if (event.key === 's') keys.s = true;
            if (event.key === 'd') keys.d = true;
            if (event.key === ' ') keys.space = true;
            if (event.key === 'q') keys.q = true;
            if (event.key === 'e') keys.e = true;
            if (event.key === 'c') keys.c = true;
        });
        document.addEventListener('keyup', (event) => {
            if (event.key === 'w') keys.w = false;
            if (event.key === 'a') keys.a = false;
            if (event.key === 's') keys.s = false;
            if (event.key === 'd') keys.d = false;
            if (event.key === ' ') keys.space = false;
            if (event.key === 'q') keys.q = false;
            if (event.key === 'e') keys.e = false;
            if (event.key === 'c') keys.c = false;
        });

        document.addEventListener('mousemove', (event) => {
            if (!aimJoystickActive) { // Only update mouse if joystick isn't active
                crosshairX = event.clientX;
                crosshairY = event.clientY;
                crosshair.style.left = crosshairX + 'px';
                crosshair.style.top = crosshairY + 'px';
                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
                raycaster.setFromCamera(mouse, camera);
                const plane = new THREE.Plane(new THREE.Vector3(0, 0, 1), -trackPosition - 50);
                raycaster.ray.intersectPlane(plane, mouseWorldPos);
            }
        });

        function updateOuterCrosshair() {
            outerCrosshairX += (crosshairX - outerCrosshairX) * 0.3;
            outerCrosshairY += (crosshairY - outerCrosshairY) * 0.4;
            outerCrosshair.style.left = outerCrosshairX + 'px';
            outerCrosshair.style.top = outerCrosshairY + 'px';
        }

        // Variables for smooth rotation
        let targetPitch = 0;
        let targetYaw = 0;
        let currentPitch = 0;
        let currentYaw = 0;
        let movementPitch = 0;
        let movementRoll = 0;
        let targetMovementPitch = 0;
        let targetMovementRoll = 0;

        // Billboards
        let billboardTimer = 0;
        let billboardCount = 0;
        const maxBillboards = 10;

        // Movement speeds
        const normalSpeed = 0.2;
        const quickSpeed = 0.4;
        const maxAngleNormal = Math.PI / 4;
        const maxAngleQuick = Math.PI / 2;

        // Brake on right click, shoot on left click
        document.addEventListener('contextmenu', (event) => event.preventDefault());
        document.addEventListener('mousedown', (event) => {
            if (event.button === 2) isBraking = true;
            if (event.button === 0 && !gameOver && !aimJoystickActive) { // Only mouse if no joystick
                shootProjectile();
            }
        });
        document.addEventListener('mouseup', (event) => {
            if (event.button === 2) isBraking = false;
        });

        function shootProjectile() {
            const currentTime = performance.now() / 1000; // Time in seconds
            const isMobile = /Mobi|Android/i.test(navigator.userAgent); // Simple mobile detection
            if (isMobile && currentTime - lastShotTime < shootCooldown) return; // Cooldown for mobile

            raycaster.setFromCamera(mouse, camera);
            const direction = raycaster.ray.direction.clone().normalize();
            const createProjectile = (offsetX = 0) => {
                const projectileGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                const projectileMaterial = new THREE.MeshBasicMaterial({ color: doubleShotActive ? 0x0000ff : 0xff0000 });
                const projectile = new THREE.Mesh(projectileGeometry, projectileMaterial);
                projectile.position.copy(spaceshipGroup.position);
                projectile.position.z -= 1;
                projectile.position.x += offsetX;
                projectile.userData.direction = direction.clone();
                projectile.userData.velocity = 1.0;
                scene.add(projectile);
                projectiles.push(projectile);
            };
            createProjectile(0);
            if (doubleShotActive) createProjectile(0.5);
            if (isMobile) lastShotTime = currentTime; // Update last shot time only on mobile
        }


        // New billboard click handlers
        let holdTimer = null;
        document.addEventListener('mousedown', (event) => {
            if (event.button !== 0 || gameOver) return;
            const mouse = new THREE.Vector2();
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(billboards);
            if (intersects.length > 0) {
                const clickedBillboard = intersects[0].object;
                if (holdTimer) clearTimeout(holdTimer);
                holdTimer = setTimeout(() => {
                    if (clickedBillboard.userData.url) {
                        window.open(clickedBillboard.userData.url, '_blank');
                    }
                    holdTimer = null;
                }, 1000);
            }
        });
        document.addEventListener('mouseup', (event) => {
            if (event.button === 0 && holdTimer) {
                clearTimeout(holdTimer);
                holdTimer = null;
            }
        });

        // Main menu logic
        const mainMenu = document.getElementById('mainMenu');
        const playerNameInput = document.getElementById('playerNameInput');
        const nameError = document.getElementById('nameError');
        const highScoreDisplay = document.getElementById('highScoreDisplay');
        highScoreDisplay.textContent = `High Score: ${highScore} (by ${localStorage.getItem('highScoreName') || 'Unknown'})`;

        const badWords = ['badword1', 'badword2', 'badword3'];
        function checkName(name) {
            return badWords.some(word => name.toLowerCase().includes(word));
        }

        function startGame() {
            const name = playerNameInput.value.trim();
            if (!name) {
                nameError.textContent = 'Please enter a name.';
                return;
            }
            if (checkName(name)) {
                nameError.textContent = 'Name contains inappropriate words. Please change it.';
                return;
            }
            playerName = name;
            mainMenu.style.display = 'none';
            document.getElementById('info').style.display = 'block';
            document.getElementById('bars').style.display = 'block';
            document.getElementById('powerUpMessage').style.display = 'block';
            crosshair.style.display = 'block';
            outerCrosshair.style.display = 'block';
            gameOver = false;
            animate();
            // backgroundMusic.play();
        }

        function restartGame() {
            document.getElementById('gameOverMenu').style.display = 'none';
            score = 0;
            lives = 3;
            trackPosition = 0;
            bossSpawned = false;
            justRestarted = true;
            invincibilityTimer = 0;
            doubleShotActive = false;
            doubleShotTimer = 0;
            brakeBar = 100;
            boostBar = 100;
            rollActive = false;
            rollCooldown = 0;
            rollAngle = 0;
            shakeTimer = 0;
            shakeIntensity = 0;
            boostShakeTimer = 0;
            boostShakeIntensity = 0;
            gameOver = false;
            spaceshipGroup.position.set(0, 0, -5);
            spaceshipGroup.rotation.set(0, 0, 0);
            destroyAllTagsOnRestart();
            projectiles.forEach(projectile => scene.remove(projectile));
            projectiles.length = 0;
            explosionParticles.forEach(particle => scene.remove(particle));
            explosionParticles.length = 0;
            if (boss) {
                scene.remove(boss);
                boss = null;
                weakSpots = [];
            }
            currentPitch = 0;
            currentYaw = 0;
            movementPitch = 0;
            movementRoll = 0;
            targetMovementPitch = 0;
            targetMovementRoll = 0;
            updateUI();
            animate();
        }

        // Scene elements
        const groundGeometry = new THREE.PlaneGeometry(100, trackLength * 2);
        const groundMaterial = new THREE.MeshBasicMaterial({ color: 0x333333 });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.position.y = -15;
        scene.add(ground);

        function spawnBillboard() {
            const textureLoader = new THREE.TextureLoader();
            const billboardTexture = textureLoader.load('textures/billboard.png');
            const billboardGeometry = new THREE.BoxGeometry(10, 6, 0.2);
            const billboardMaterial = new THREE.MeshBasicMaterial({ 
                map: billboardTexture,
                side: THREE.DoubleSide
            });
            const billboard = new THREE.Mesh(billboardGeometry, billboardMaterial);
            billboard.userData = {url: 'https://x.com/AlexerSalcido/'};
            const side = Math.random() < 0.5 ? -20 : 20;
            billboard.position.set(side, 5, -trackPosition - 50);
            scene.add(billboard);
            billboards.push(billboard);
        }

        function spawnSideShip() {
            const shipGeometry = new THREE.BoxGeometry(3, 1, 5);
            const shipMaterial = new THREE.MeshBasicMaterial({ color: 0x5555ff });
            const ship = new THREE.Mesh(shipGeometry, shipMaterial);
            const side = Math.random() < 0.5 ? -30 : 30;
            ship.position.set(side, Math.random() * 10 - 5, -trackPosition - 50);
            scene.add(ship);
            sideShips.push(ship);
        }

        function spawnEnemy(type = 'default') {
            let enemy;
            if (type === 'purple') {
                enemy = createTurretEnemy();
                enemy.position.set(Math.random() * 20 - 10, Math.random() * 20 - 10, -trackPosition - 50);
                enemy.health = 1;
                enemy.userData.type = 'purple';
            } else if (type === 'green') {
                enemy = createSpaceshipEnemy(0x00ff00);
                enemy.position.set(Math.random() * 20 - 10, Math.random() * 20 - 10, -trackPosition - 20);
                enemy.health = 1;
                enemy.userData.type = 'green';
            } else if (type === 'pink') {
                enemy = createSpaceshipEnemy(0xff69b4);
                const side = Math.random() < 0.5 ? -15 : 15;
                enemy.position.set(side, Math.random() * 20 - 10, spaceshipGroup.position.z + 10);
                enemy.health = 1;
                enemy.userData.type = 'pink';
                enemy.userData.state = 'movingToFront';
            } else if (type === 'orange') {
                enemy = createSpaceshipEnemy(0xffa500);
                enemy.position.set(Math.random() * 20 - 10, Math.random() * 20 - 10, -trackPosition - 50);
                enemy.health = 1;
                enemy.userData.type = 'orange';
                enemy.userData.angle = Math.random() * Math.PI * 2;
            } else if (type === 'cyan') {
                enemy = createSpaceshipEnemy(0x00ffff);
                enemy.position.set(Math.random() * 20 - 10, Math.random() * 20 - 10, -trackPosition - 50);
                enemy.health = 1;
                enemy.userData.type = 'cyan';
                enemy.userData.angle = Math.random() * Math.PI * 2;
            } else {
                enemy = createSpaceshipEnemy(0xff0000);
                enemy.position.set(Math.random() * 20 - 10, Math.random() * 20 - 10, -trackPosition - 50);
                enemy.health = 1;
                enemy.userData.type = 'default';
            }
            scene.add(enemy);
            enemies.push(enemy);
        }

        function createSpaceshipEnemy(color) {
            const group = new THREE.Group();
            const bodyGeometry = new THREE.ConeGeometry(0.4, 1.5, 8);
            const bodyMaterial = new THREE.MeshBasicMaterial({ color });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.rotation.x = Math.PI;
            group.add(body);
            const wingGeometry = new THREE.BoxGeometry(1.2, 0.1, 0.5);
            const wingMaterial = new THREE.MeshBasicMaterial({ color: 0xaaaaaa });
            const leftWing = new THREE.Mesh(wingGeometry, wingMaterial);
            const rightWing = new THREE.Mesh(wingGeometry, wingMaterial);
            leftWing.position.set(-0.8, 0, 0);
            rightWing.position.set(0.8, 0, 0);
            leftWing.rotation.z = Math.PI / 6;
            rightWing.rotation.z = -Math.PI / 6;
            group.add(leftWing, rightWing);
            const cockpitGeometry = new THREE.SphereGeometry(0.2, 8, 8);
            const cockpitMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
            const cockpit = new THREE.Mesh(cockpitGeometry, cockpitMaterial);
            cockpit.position.set(0, 0.2, -0.5);
            group.add(cockpit);
            return group;
        }

        function createTurretEnemy() {
            const group = new THREE.Group();
            const baseGeometry = new THREE.CylinderGeometry(0.8, 0.8, 0.5, 16);
            const baseMaterial = new THREE.MeshBasicMaterial({ color: 0x800080 });
            const base = new THREE.Mesh(baseGeometry, baseMaterial);
            group.add(base);
            const barrelGeometry = new THREE.BoxGeometry(0.2, 0.2, 1.5);
            const barrelMaterial = new THREE.MeshBasicMaterial({ color: 0x555555 });
            const barrel = new THREE.Mesh(barrelGeometry, barrelMaterial);
            barrel.position.set(0, 0.4, 0.5);
            group.add(barrel);
            return group;
        }

        function createNameTag(object, name) {
            const div = document.createElement('div');
            div.className = 'name-tag';
            div.textContent = name;
            document.body.appendChild(div);
            object.userData.nameTag = div;
        }

        function updateNameTags() {
            [enemies, mountains, billboards, sideShips].forEach(collection => {
                collection.forEach(obj => {
                    const pos = new THREE.Vector3();
                    obj.getWorldPosition(pos);
                    const screenPos = pos.project(camera);
                    const x = (screenPos.x + 1) * window.innerWidth / 2;
                    const y = (-screenPos.y + 1) * window.innerHeight / 2;
                    obj.userData.nameTag.style.left = `${x}px`;
                    obj.userData.nameTag.style.top = `${y - 20}px`;
                    obj.userData.nameTag.style.display = (screenPos.z > 0 && screenPos.z < 1) ? 'block' : 'none';
                });
            });
        }

        function spawnObstacle() {
            const obstacleGeometry = new THREE.BoxGeometry(2, 5, 2);
            const obstacleMaterial = new THREE.MeshBasicMaterial({ color: 0x888888 });
            const obstacle = new THREE.Mesh(obstacleGeometry, obstacleMaterial);
            const spawnFromTop = Math.random() < 0.5;
            obstacle.position.set(
                Math.random() * 20 - 10,
                spawnFromTop ? 10 : -2.5,
                -trackPosition - 50
            );
            scene.add(obstacle);
            obstacles.push(obstacle);
        }

        function spawnPowerUp(type) {
            let powerUp;
            if (type === 'extraLife') {
                const heartShape = new THREE.Shape();
                heartShape.moveTo(0, 0);
                heartShape.quadraticCurveTo(0.5, 0.5, 1, 0);
                heartShape.quadraticCurveTo(1.5, -0.5, 0, -1);
                heartShape.quadraticCurveTo(-1.5, -0.5, -1, 0);
                heartShape.quadraticCurveTo(-0.5, 0.5, 0, 0);
                const extrudeSettings = { depth: 0.2, bevelEnabled: false };
                const heartGeometry = new THREE.ExtrudeGeometry(heartShape, extrudeSettings);
                const heartMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
                powerUp = new THREE.Mesh(heartGeometry, heartMaterial);
            } else {
                const prismGeometry = new THREE.CylinderGeometry(0.5, 0.5, 1, 3);
                const prismMaterial = new THREE.MeshBasicMaterial({ color: 0xffd700 });
                powerUp = new THREE.Mesh(prismGeometry, prismMaterial);
            }
            powerUp.position.set(Math.random() * 20 - 10, Math.random() * 20 - 10, -trackPosition - 50);
            powerUp.userData.type = type;
            scene.add(powerUp);
            powerUps.push(powerUp);
        }

        let boss = null;
        let weakSpots = [];
        function spawnBoss() {
            const group = new THREE.Group();
            const bodyGeometry = new THREE.BoxGeometry(3, 4, 2);
            const bodyMaterial = new THREE.MeshBasicMaterial({ color: bossOriginalColor });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            group.add(body);
            const armGeometry = new THREE.CylinderGeometry(0.5, 0.5, 3, 8);
            const armMaterial = new THREE.MeshBasicMaterial({ color: 0x666666 });
            const leftArm = new THREE.Mesh(armGeometry, armMaterial);
            const rightArm = new THREE.Mesh(armGeometry, armMaterial);
            leftArm.position.set(-2, 0, 0);
            rightArm.position.set(2, 0, 0);
            leftArm.rotation.z = Math.PI / 4;
            rightArm.rotation.z = -Math.PI / 4;
            group.add(leftArm, rightArm);
            const headGeometry = new THREE.SphereGeometry(1, 16, 16);
            const headMaterial = new THREE.MeshBasicMaterial({ color: 0x333333 });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.set(0, 2.5, 0);
            group.add(head);
            const eyeGeometry = new THREE.SphereGeometry(0.2, 8, 8);
            const eyeMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });
            const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            leftEye.position.set(-0.4, 2.7, 0.8);
            rightEye.position.set(0.4, 2.7, 0.8);
            group.add(leftEye, rightEye);
            group.position.set(0, 0, -trackPosition - 20);
            group.userData.health = 50;
            group.userData.maxHealth = 50;
            if (showEnemyTags) createNameTag(group, "Zorgon the Devastator");
            scene.add(group);
            boss = group;
            bossSpawned = true;
            console.log(`Boss spawned, health: ${boss.userData.health}`);
            const weakSpotGeometry = new THREE.SphereGeometry(0.5, 8, 8);
            const weakSpotMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            for (let i = 0; i < 3; i++) {
                const weakSpot = new THREE.Mesh(weakSpotGeometry, weakSpotMaterial);
                if (i === 0) weakSpot.position.set(-2, -1, 0);
                else if (i === 1) weakSpot.position.set(2, -1, 0);
                else weakSpot.position.set(0, 3, 0);
                weakSpot.userData.isWeakSpot = true;
                group.add(weakSpot);
                weakSpots.push(weakSpot);
            }
            const healthBar = document.createElement('div');
            healthBar.id = 'bossHealthBar';
            healthBar.style.position = 'absolute';
            healthBar.style.top = '10px';
            healthBar.style.left = '50%';
            healthBar.style.transform = 'translateX(-50%)';
            healthBar.style.width = '600px';
            healthBar.style.height = '20px';
            healthBar.style.background = '#333';
            healthBar.style.border = '1px solid #fff';
            const fill = document.createElement('div');
            fill.style.width = '100%';
            fill.style.height = '100%';
            fill.style.background = 'red';
            healthBar.appendChild(fill);
            const label = document.createElement('div');
            label.textContent = 'Zorgon the Devastator';
            label.style.color = 'white';
            label.style.textAlign = 'center';
            label.style.fontFamily = 'Roboto, sans-serif';
            document.body.appendChild(healthBar);
            document.body.appendChild(label);
            label.style.position = 'absolute';
            label.style.top = '35px';
            label.style.left = '50%';
            label.style.transform = 'translateX(-50%)';
        }

        function explodeBoss() {
            for (let i = 0; i < 20; i++) {
                const particle = new THREE.Mesh(
                    new THREE.SphereGeometry(0.2, 8, 8),
                    new THREE.MeshBasicMaterial({ color: 0xff0000 })
                );
                particle.position.copy(boss.position);
                const velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 2,
                    (Math.random() - 0.5) * 2,
                    (Math.random() - 0.5) * 2
                ).normalize().multiplyScalar(Math.random() * 2);
                particle.userData.velocity = velocity;
                scene.add(particle);
                projectiles.push(particle);
            }
            bossDestroySound.play();
            scene.remove(boss);
            document.body.removeChild(document.getElementById('bossHealthBar'));
            document.body.removeChild(document.querySelector('div[style*="top: 35px"]'));
            boss = null;
            weakSpots = [];
            score += 100;
            setTimeout(() => {
                document.getElementById('gameOverMenu').style.display = 'flex';
                document.getElementById('gameOverMenu').querySelector('h2').textContent = "Level Completed!";
                document.getElementById('finalScore').textContent = score;
                if (score > highScore) {
                    highScore = score;
                    localStorage.setItem('highScore', highScore);
                    localStorage.setItem('highScoreName', playerName);
                }
            }, 2000);
        }

        function enemyShoot(enemy) {
            const projectileGeometry = new THREE.SphereGeometry(0.1, 8, 8);
            const projectileMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });
            const projectile = new THREE.Mesh(projectileGeometry, projectileMaterial);
            projectile.position.copy(enemy.position);
            if (enemy.userData.type === 'purple') {
                const directionToPlayer = spaceshipGroup.position.clone().sub(enemy.position).normalize();
                projectile.userData.direction = directionToPlayer;
            } else {
                projectile.userData.direction = new THREE.Vector3(0, 0, 1);
            }
            projectile.userData.velocity = 0.3;
            scene.add(projectile);
            enemyProjectiles.push(projectile);
        }

        function triggerCameraShake(intensity, duration) {
            shakeIntensity = intensity;
            shakeTimer = duration;
        }

        function displayPowerUpMessage(message) {
            const messageDiv = document.getElementById('powerUpMessage');
            messageDiv.textContent = message;
            setTimeout(() => messageDiv.textContent = '', 3000);
        }

        function updateUI() {
            document.getElementById('score').textContent = score;
            const livesDisplay = document.getElementById('livesDisplay');
            livesDisplay.innerHTML = '';
            for (let i = 0; i < lives; i++) {
                const heart = document.createElement('div');
                heart.className = 'heart';
                livesDisplay.appendChild(heart);
            }
            document.getElementById('brakeBarFill').style.width = `${Math.floor(brakeBar)}%`;
            document.getElementById('boostBarFill').style.width = `${Math.floor(boostBar)}%`;
        }

        function checkCollisions() {
            projectiles.forEach((projectile, pIndex) => {
                enemies.forEach((enemy, eIndex) => {
                    const distance = projectile.position.distanceTo(enemy.position);
                    if (distance < 3) {
                        enemy.health -= 1;
                        if (enemy.health <= 0) {
                            scene.remove(enemy);
                            enemies.splice(eIndex, 1);
                            score += 10;
                            enemyDestroySound.play();
                            triggerCameraShake(0.1, 0.2);
                        }
                        scene.remove(projectile);
                        projectiles.splice(pIndex, 1);
                    }
                });

                if (boss) {
                    const distanceToBoss = projectile.position.distanceTo(boss.position);
                    let hitWeakSpot = false;
                    if (!hitWeakSpot && distanceToBoss < 3) {
                        boss.userData.health -= 1;
                        bossHitTimer = 0.5;
                        bossHitCount = 0;
                        boss.children[0].material.color.setHex(bossHitColor);
                        scene.remove(projectile);
                        projectiles.splice(pIndex, 1);
                        enemyDestroySound.play();
                        triggerCameraShake(0.1, 0.2);
                    }
                    if (boss.userData.health <= 0) explodeBoss();
                }
            });

            let healthBar = document.getElementById('bossHealthBar');
            if (healthBar) {
                const fill = healthBar.children[0];
                fill.style.width = `${(boss.userData.health / boss.userData.maxHealth) * 100}%`;
            }

            if (invincibilityTimer <= 0) {
                enemyProjectiles.forEach((projectile, pIndex) => {
                    const distance = projectile.position.distanceTo(spaceshipGroup.position);
                    if (distance < 1) {
                        lives -= 1;
                        invincibilityTimer = 3;
                        doubleShotActive = false;
                        scene.remove(projectile);
                        enemyProjectiles.splice(pIndex, 1);
                        playerHitSound.play();
                        triggerCameraShake(0.3, 0.5);
                        if (lives <= 0) {
                            gameOver = true;
                            document.getElementById('finalScore').textContent = score;
                            document.getElementById('gameOverMenu').style.display = 'flex';
                            if (score > highScore) {
                                highScore = score;
                                localStorage.setItem('highScore', highScore);
                                localStorage.setItem('highScoreName', playerName);
                            }
                        }
                    }
                });

                obstacles.forEach((obstacle) => {
                    const distance = spaceshipGroup.position.distanceTo(obstacle.position);
                    if (distance < 2) {
                        lives -= 1;
                        invincibilityTimer = 3;
                        doubleShotActive = false;
                        playerHitSound.play();
                        triggerCameraShake(0.3, 0.5);
                        if (lives <= 0) {
                            gameOver = true;
                            document.getElementById('finalScore').textContent = score;
                            document.getElementById('gameOverMenu').style.display = 'flex';
                            if (score > highScore) {
                                highScore = score;
                                localStorage.setItem('highScore', highScore);
                                localStorage.setItem('highScoreName', playerName);
                            }
                        }
                    }
                });

                if (spaceshipGroup.position.y < -14) {
                    lives -= 1;
                    invincibilityTimer = 3;
                    doubleShotActive = false;
                    playerHitSound.play();
                    triggerCameraShake(0.3, 0.5);
                    spaceshipGroup.position.y = -14;
                    if (lives <= 0) {
                        gameOver = true;
                        document.getElementById('finalScore').textContent = score;
                        document.getElementById('gameOverMenu').style.display = 'flex';
                        if (score > highScore) {
                            highScore = score;
                            localStorage.setItem('highScore', highScore);
                            localStorage.setItem('highScoreName', playerName);
                        }
                    }
                }

                enemies.forEach((enemy, eIndex) => {
                    const distance = spaceshipGroup.position.distanceTo(enemy.position);
                    if (distance < 1) {
                        lives -= 1;
                        invincibilityTimer = 3;
                        doubleShotActive = false;
                        scene.remove(enemy);
                        enemies.splice(eIndex, 1);
                        playerHitSound.play();
                        triggerCameraShake(0.3, 0.5);
                        if (lives <= 0) {
                            gameOver = true;
                            document.getElementById('finalScore').textContent = score;
                            document.getElementById('gameOverMenu').style.display = 'flex';
                            if (score > highScore) {
                                highScore = score;
                                localStorage.setItem('highScore', highScore);
                                localStorage.setItem('highScoreName', playerName);
                            }
                        }
                    }
                });
            }

            powerUps.forEach((powerUp, pIndex) => {
                const distance = spaceshipGroup.position.distanceTo(powerUp.position);
                if (distance < 2) {
                    if (powerUp.userData.type === 'extraLife') {
                        if (lives < 3) {
                            lives += 1;
                            displayPowerUpMessage('Extra Life!');
                        } else if (lives < 6) {
                            lives += 1;
                            displayPowerUpMessage('Bonus Life! Max 6');
                        } else {
                            displayPowerUpMessage('Max Lives Reached!');
                        }
                    } else if (powerUp.userData.type === 'doubleShot') {
                        doubleShotActive = true;
                        displayPowerUpMessage('Double Shot!');
                    }
                    scene.remove(powerUp);
                    powerUps.splice(pIndex, 1);
                }
            });
        }

        function despawnEnemiesOutOfBounds(restart) {
            if (restart) {
                while (enemies.length > 0) {
                    const enemy = enemies[0];
                    scene.remove(enemy);
                    enemies.splice(0, 1);
                }
            } else {
                let i = enemies.length;
                while (i--) {
                    const enemy = enemies[i];
                    if (
                        enemy.position.z > spaceshipGroup.position.z + 10 ||
                        Math.abs(enemy.position.x - spaceshipGroup.position.x) > 20 ||
                        Math.abs(enemy.position.y - spaceshipGroup.position.y) > 20
                    ) {
                        scene.remove(enemy);
                        enemies.splice(i, 1);
                    }
                }
            }
        }

        function destroyAllTagsOnRestart() {
            function cleanCollection(collection, collectionName) {
                console.log(`Cleaning collection: ${collectionName}, Initial length: ${collection.length}`);
                let index = collection.length;
                while (index--) {
                    const item = collection[index];
                    try {
                        scene.remove(item);
                    } catch (error) {
                        console.error(`Error cleaning item in ${collectionName}:`, error);
                    }
                    collection.splice(index, 1);
                }
                console.log(`After cleaning ${collectionName}, length: ${collection.length}`);
            }
            cleanCollection(enemies, "enemies");
            cleanCollection(mountains, "mountains");
            cleanCollection(billboards, "billboards");
            cleanCollection(sideShips, "sideShips");
            cleanCollection(obstacles, "obstacles");
            cleanCollection(powerUps, "powerUps");
        }


        // Nipple.js Joystick Setup
            const isMobile = /Mobi|Android/i.test(navigator.userAgent);
            let movementJoystick, aimJoystick;

            if (isMobile) {
                movementJoystick = nipplejs.create({
                    zone: document.getElementById('movementJoystick'),
                    mode: 'static',
                    position: { left: '50%', top: '50%' },
                    color: 'cyan',
                    size: 100
                });

                aimJoystick = nipplejs.create({
                    zone: document.getElementById('aimJoystick'),
                    mode: 'static',
                    position: { left: '50%', top: '50%' },
                    color: 'red',
                    size: 100
                });

                movementJoystick.on('start', () => {
                    movementJoystickActive = true;
                }).on('move', (evt, data) => {
                    if (data.direction) {
                        const angle = data.angle.radian;
                        const force = data.distance / 50; // Max distance normalized
                        keys.w = angle > Math.PI / 4 && angle < 3 * Math.PI / 4;
                        keys.s = angle > 5 * Math.PI / 4 && angle < 7 * Math.PI / 4;
                        keys.a = angle > 3 * Math.PI / 4 && angle < 5 * Math.PI / 4;
                        keys.d = angle > 7 * Math.PI / 4 || angle < Math.PI / 4;
                    }
                }).on('end', () => {
                    movementJoystickActive = false;
                    keys.w = keys.a = keys.s = keys.d = false;
                });

                aimJoystick.on('start', () => {
                    aimJoystickActive = true;
                }).on('move', (evt, data) => {
                    if (data.direction) {
                        const angle = data.angle.radian;
                        const force = data.distance / 50; // Max distance normalized
                        crosshairX += Math.cos(angle) * force * 10;
                        crosshairY -= Math.sin(angle) * force * 10; // Y is inverted
                        crosshairX = Math.max(0, Math.min(window.innerWidth, crosshairX));
                        crosshairY = Math.max(0, Math.min(window.innerHeight, crosshairY));
                        crosshair.style.left = crosshairX + 'px';
                        crosshair.style.top = crosshairY + 'px';
                        mouse.x = (crosshairX / window.innerWidth) * 2 - 1;
                        mouse.y = -(crosshairY / window.innerHeight) * 2 + 1;
                        raycaster.setFromCamera(mouse, camera);
                        const plane = new THREE.Plane(new THREE.Vector3(0, 0, 1), -trackPosition - 50);
                        raycaster.ray.intersectPlane(plane, mouseWorldPos);
                        shootProjectile();
                    }
                }).on('end', () => {
                    aimJoystickActive = false;
                });
            }





        // Game loop
        function animate() {
            if (gameOver) return;
            requestAnimationFrame(animate);

            currentTrackSpeed = baseTrackSpeed;
            if (isBraking && brakeBar > 0) {
                currentTrackSpeed *= 0.5;
                brakeBar = Math.max(0, brakeBar - 1);
                brakeRegenDelay = brakeBar === 0 ? 2 : 0;
            } else if ((keys.space && boostBar > 0) || rollActive) {
                currentTrackSpeed *= 2;
                boostBar = Math.max(0, boostBar - 1);
                boostRegenDelay = boostBar === 0 ? 2 : 0;
                leftTrail.visible = true;
                rightTrail.visible = true;
                boostShakeTimer = 0.1;
                boostShakeIntensity = 0.05;
            } else {
                leftTrail.visible = false;
                rightTrail.visible = false;
                boostShakeTimer = 0;
                boostShakeIntensity = 0;
            }

            if (!isBraking) {
                if (brakeRegenDelay > 0) brakeRegenDelay -= 1 / 60;
                else brakeBar = Math.min(100, brakeBar + 0.5);
            }
            if (!keys.space) {
                if (boostRegenDelay > 0) boostRegenDelay -= 1 / 60;
                else boostBar = Math.min(100, boostBar + 0.5);
            }

            if (keys.c && !rollActive && rollCooldown <= 0) {
                rollActive = true;
                rollAngle = 0;
                invincibilityTimer = 2;
                rollCooldown = 2;
                if (keys.a || keys.q) rollDirection = 1;
                else if (keys.d || keys.e) rollDirection = -1;
                else rollDirection = 1;
                leftTrail.visible = true;
                rightTrail.visible = true;
            }
            if (rollActive) {
                rollAngle += 0.3 * rollDirection;
                spaceshipGroup.rotation.z = movementRoll + Math.sin(rollAngle) * Math.PI;
                if (rollAngle >= 4 * Math.PI || rollAngle <= -4 * Math.PI) {
                    rollActive = false;
                    rollAngle = 0;
                    rollDirection = 1;
                    spaceshipGroup.rotation.z = movementRoll;
                    leftTrail.visible = false;
                    rightTrail.visible = false;
                }
            }
            if (rollCooldown > 0) rollCooldown -= 1 / 60;

            trackPosition += currentTrackSpeed;
            spaceshipGroup.position.z = -trackPosition;

            if (boostShakeTimer > 0) {
                boostShakeTimer -= 1 / 60;
                const shakeOffset = new THREE.Vector3(
                    (Math.random() - 0.5) * boostShakeIntensity,
                    (Math.random() - 0.5) * boostShakeIntensity,
                    0
                );
                spaceshipGroup.position.add(shakeOffset);
            }

            const maxX = 20 - 0.25;
            const minX = -20 + 0.25;
            const maxY = 20 - 0.25;
            const minY = -20 + 0.25;

            if (keys.q && spaceshipGroup.position.x > minX) {
                spaceshipGroup.position.x -= quickSpeed;
            } else if (keys.a && spaceshipGroup.position.x > minX) {
                spaceshipGroup.position.x -= normalSpeed;
            }
            if (keys.e && spaceshipGroup.position.x < maxX) {
                spaceshipGroup.position.x += quickSpeed;
            } else if (keys.d && spaceshipGroup.position.x < maxX) {
                spaceshipGroup.position.x += normalSpeed;
            }
            if (keys.w && spaceshipGroup.position.y < maxY) spaceshipGroup.position.y += normalSpeed;
            if (keys.s && spaceshipGroup.position.y > minY) spaceshipGroup.position.y -= normalSpeed;

            targetMovementPitch = 0;
            targetMovementRoll = 0;

            if (keys.w) targetMovementPitch = maxAngleNormal;
            else if (keys.s) targetMovementPitch = -maxAngleNormal;

            if (keys.q) targetMovementRoll = maxAngleQuick;
            else if (keys.e) targetMovementRoll = -maxAngleQuick;
            else if (keys.a) targetMovementRoll = maxAngleNormal;
            else if (keys.d) targetMovementRoll = -maxAngleNormal;

            movementPitch += (targetMovementPitch - movementPitch) * 0.1;
            movementRoll += (targetMovementRoll - movementRoll) * 0.1;

            if (mouseWorldPos) {
                const directionToCrosshair = mouseWorldPos.clone().sub(spaceshipGroup.position).normalize();
                targetYaw = Math.atan2(directionToCrosshair.x, directionToCrosshair.z);
                targetPitch = Math.asin(directionToCrosshair.y);
                currentPitch += (targetPitch + movementPitch - currentPitch) * 0.1;
                currentYaw += (targetYaw - currentYaw) * 0.1;
                if (!rollActive) {
                    spaceshipGroup.rotation.x = currentPitch;
                    spaceshipGroup.rotation.y = currentYaw;
                    spaceshipGroup.rotation.z = movementRoll;
                }
            }

            const distanceFromCenter = Math.max(Math.abs(spaceshipGroup.position.x), Math.abs(spaceshipGroup.position.y));
            let targetCameraPos = new THREE.Vector3(0, 2, spaceshipGroup.position.z + 5);

            if (distanceFromCenter < firstZoneLimit) {
                targetCameraPos.set(0, 2, spaceshipGroup.position.z + 5);
            } else if (distanceFromCenter >= firstZoneLimit && distanceFromCenter <= secondZoneLimit) {
                targetCameraPos.set(
                    spaceshipGroup.position.x * 0.2,
                    spaceshipGroup.position.y * 0.2 + 2,
                    spaceshipGroup.position.z + 5
                );
            } else {
                const offsetFactor = 0.4;
                targetCameraPos.set(
                    spaceshipGroup.position.x * offsetFactor,
                    spaceshipGroup.position.y * offsetFactor + 2,
                    spaceshipGroup.position.z + 5
                );
            }

            camera.position.lerp(targetCameraPos, 0.1);
            camera.lookAt(camera.position.x, camera.position.y, camera.position.z - 100);

            if (shakeTimer > 0) {
                shakeTimer -= 1 / 60;
                const shakeOffset = new THREE.Vector3(
                    (Math.random() - 0.5) * shakeIntensity,
                    (Math.random() - 0.5) * shakeIntensity,
                    (Math.random() - 0.5) * shakeIntensity
                );
                camera.position.add(shakeOffset);
            } else {
                shakeIntensity = 0;
            }

            const maxEnemies = 10;
            if (enemies.length < maxEnemies && Math.random() < 0.02 && trackPosition < trackLength - 100) {
                const type = Math.random();
                if (type < 0.2) spawnEnemy('purple');
                else if (type < 0.4) spawnEnemy('green');
                else if (type < 0.6) spawnEnemy('pink');
                else if (type < 0.8) spawnEnemy('orange');
                else if (type < 0.9) spawnEnemy('cyan');
                else spawnEnemy('default');
            }

            if (Math.random() < 0.01 && trackPosition < trackLength - 100) spawnObstacle();
            if (Math.random() < 0.005 && trackPosition < trackLength - 100) {
                const type = Math.random() < 0.5 ? 'extraLife' : 'doubleShot';
                spawnPowerUp(type);
            }
            if (Math.random() < 0.005 && trackPosition < trackLength - 100) spawnBillboard();
            if (Math.random() < 0.005 && trackPosition < trackLength - 100) spawnSideShip();

            if (trackPosition >= trackLength - 100 && !bossSpawned && lives > 0) spawnBoss();
            if (justRestarted && trackPosition > 10) justRestarted = false;

            projectiles.forEach((projectile, index) => {
                if (projectile.userData.direction) {
                    projectile.position.add(projectile.userData.direction.clone().multiplyScalar(projectile.userData.velocity));
                } else if (projectile.userData.velocity) {
                    projectile.position.add(projectile.userData.velocity.clone());
                }
                if (projectile.position.z < -trackPosition - 50 || Math.abs(projectile.position.x) > 50 || Math.abs(projectile.position.y) > 50) {
                    scene.remove(projectile);
                    projectiles.splice(index, 1);
                }
            });

            enemies.forEach((enemy) => {
                if (enemy.userData.type === 'purple' && Math.random() < 0.005) {
                    enemyShoot(enemy);
                } else if (enemy.userData.type === 'green') {
                    const targetPos = spaceshipGroup.position.clone();
                    targetPos.z -= 20;
                    const directionToTarget = targetPos.sub(enemy.position).normalize();
                    const distanceToTarget = enemy.position.distanceTo(targetPos);
                    if (distanceToTarget > 1) enemy.position.add(directionToTarget.multiplyScalar(0.1));
                } else if (enemy.userData.type === 'pink') {
                    if (enemy.userData.state === 'movingToFront') {
                        enemy.position.z -= 0.5;
                        if (enemy.position.z < spaceshipGroup.position.z - 20) {
                            enemy.userData.state = 'inFront';
                            enemy.position.x = Math.random() * 20 - 10;
                            enemy.position.y = Math.random() * 20 - 10;
                        }
                    } else {
                        const targetPos = spaceshipGroup.position.clone();
                        targetPos.z -= 20;
                        const directionToTarget = targetPos.sub(enemy.position).normalize();
                        const distanceToTarget = enemy.position.distanceTo(targetPos);
                        if (distanceToTarget > 1) enemy.position.add(directionToTarget.multiplyScalar(0.1));
                    }
                } else if (enemy.userData.type === 'orange') {
                    const targetPos = spaceshipGroup.position.clone();
                    targetPos.z -= 20;
                    const directionToTarget = targetPos.sub(enemy.position).normalize();
                    const distanceToTarget = enemy.position.distanceTo(targetPos);
                    if (distanceToTarget > 1) enemy.position.add(directionToTarget.multiplyScalar(0.1));
                    if (Math.random() < 0.005) {
                        const directionToPlayer = spaceshipGroup.position.clone().sub(enemy.position).normalize();
                        const projectileGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                        const projectileMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });
                        const projectile = new THREE.Mesh(projectileGeometry, projectileMaterial);
                        projectile.position.copy(enemy.position);
                        projectile.userData.direction = directionToPlayer;
                        projectile.userData.velocity = 0.3;
                        scene.add(projectile);
                        enemyProjectiles.push(projectile);
                    }
                } else if (enemy.userData.type === 'cyan') {
                    const targetPos = spaceshipGroup.position.clone();
                    const directionToTarget = targetPos.sub(enemy.position).normalize();
                    const distanceToTarget = enemy.position.distanceTo(targetPos);
                    if (distanceToTarget > 1) enemy.position.add(directionToTarget.multiplyScalar(0.05));
                } else if (Math.random() < 0.01) {
                    enemyShoot(enemy);
                }
            });

            despawnEnemiesOutOfBounds();

            enemyProjectiles.forEach((projectile, index) => {
                if (projectile.userData.direction) {
                    projectile.position.add(projectile.userData.direction.clone().multiplyScalar(projectile.userData.velocity));
                } else {
                    projectile.position.z += 0.3;
                }
                if (projectile.position.z > -trackPosition + 50) {
                    scene.remove(projectile);
                    enemyProjectiles.splice(index, 1);
                }
            });

            if (bossHitTimer > 0) {
                bossHitTimer -= 1 / 60;
                if (bossHitTimer <= 0) {
                    bossHitCount++;
                    if (bossHitCount < 2) {
                        boss.children[0].material.color.setHex(boss.children[0].material.color.getHex() === bossOriginalColor ? bossHitColor : bossOriginalColor);
                        bossHitTimer = 0.5;
                    } else {
                        boss.children[0].material.color.setHex(bossOriginalColor);
                        bossHitCount = 0;
                    }
                }
            }

            if (boss) {
                boss.position.z = spaceshipGroup.position.z - 20;
                boss.position.x = Math.sin(trackPosition * 0.1) * 5;
                boss.position.y = Math.sin(trackPosition * 0.5) * 3;
                if (Math.random() < 0.05) enemyShoot(boss);
            }

            if (bossHitTimer > 0) {
                bossHitTimer -= 1 / 60;
                if (bossHitTimer <= 0) boss.children[0].material.color.setHex(bossOriginalColor);
            }

            if (invincibilityTimer > 0) {
                invincibilityTimer -= 1 / 60;
                spaceshipGroup.children.forEach(child => child.material.color.setHex(0xffff00));
            } else {
                spaceshipGroup.children[0].material.color.setHex(0xaaaaaa);
                spaceshipGroup.children[1].material.color.setHex(0x00ff00);
                spaceshipGroup.children[2].material.color.setHex(0x00ff00);
                spaceshipGroup.children[3].material.color.setHex(0x0000ff);
            }

            billboards.forEach((billboard, index) => {
                if (billboard.position.z > spaceshipGroup.position.z + 10) {
                    scene.remove(billboard);
                    billboards.splice(index, 1);
                }
            });

            sideShips.forEach((ship, index) => {
                if (ship.position.z > spaceshipGroup.position.z + 10) {
                    scene.remove(ship);
                    sideShips.splice(index, 1);
                }
            });

            obstacles.forEach((obstacle, index) => {
                if (obstacle.position.z > spaceshipGroup.position.z + 10) {
                    scene.remove(obstacle);
                    obstacles.splice(index, 1);
                }
            });

            powerUps.forEach((powerUp, index) => {
                if (powerUp.position.z > spaceshipGroup.position.z + 10) {
                    scene.remove(powerUp);
                    powerUps.splice(index, 1);
                }
            });

            updateOuterCrosshair();
            checkCollisions();
            updateUI();
            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
