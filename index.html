<!DOCTYPE html>
<html lang="en">
<head>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-22GVPJFMS0"></script>
    <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-22GVPJFMS0');
    </script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ultra Hyper Radical Space Squadron</title>
    <link href="https://fonts.googleapis.com/css2?family=Bebas+Neue&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400&display=swap" rel="stylesheet">
    <style>
        body { margin: 0; overflow: hidden; background: #000; }
        #mainMenu {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            font-family: 'Roboto', Arial, sans-serif; 
            z-index: 10;
        }
        #mainMenu h1 {
            font-family: 'Bebas Neue', sans-serif; 
            font-size: 60px; 
            margin: 0; 
            line-height: 1; 
            text-align: center;
        }
        #mainMenu input {
            padding: 10px;
            font-size: 18px;
            margin: 10px 0; 
            width: 200px;
            font-family: 'Roboto', sans-serif;
        }
        #mainMenu button {
            padding: 10px 20px;
            font-size: 18px;
            cursor: pointer;
            font-family: 'Roboto', sans-serif;
        }
        #mainMenu p {
            color: red;
            margin: 10px 0;
            font-family: 'Roboto', sans-serif;
        }
        #mainMenu .description, #mainMenu .controls, #mainMenu .power-ups {
            font-size: 12px;
            margin: 5px 0;
            text-align: center;
            max-width: 400px; 
        }


        
        #mainMenu .controls strong, #mainMenu .power-ups strong {
            color: cyan; 

        }
        #mainMenu .sponsor {
            position: absolute;
            bottom: 20px;
            font-size: 20px;
            
            font-family: 'Bebas Neue', sans-serif; 
        }
        #mainMenu .sponsor a {
            color: #00ffff; 
            text-decoration: none;
        }
        #mainMenu .sponsor a:hover {
            text-decoration: underline;
        }

        #mainMenu .credit {
            font-size: 14px;
            font-family: 'Roboto', sans-serif;
            margin: 5px 0; 
        }
        #mainMenu .credit a.author {
            color: #00ffff; 
            text-decoration: none;
        }
        #mainMenu .credit a.author:hover {
            text-decoration: underline; 
        }
        #mainMenu .credit span {
            color: white; 
        }


        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-family: Arial;
            display: flex;
            align-items: center;
            margin-bottom: 20px; 
        }

        #scoreDisplay { 
            margin-right: 30px; 
        }

        #livesDisplay { 
            display: flex; 
            align-items: center;
            margin-left: 20px; 
        }

        .heart {
            width: 20px;
            height: 20px;
            background: red;
            position: relative;
            margin-right: 15px; 
            transform: rotate(-45deg);
        }

        .heart:before,
        .heart:after {
            content: '';
            width: 20px;
            height: 20px;
            background: red;
            border-radius: 50%;
            position: absolute;
        }
        .heart:before {
            top: -10px;
            left: 0;
        }
        .heart:after {
            left: 10px;
            top: 0;
        }
        #bars {
            position: absolute;
            top: 40px;
            left: 10px;
            color: white;
            font-family: Arial;
        }
        .bar-label { margin-bottom: 5px; }
        .bar-container {
            width: 100px;
            height: 10px;
            background: #333;
            border: 1px solid #fff;
            position: relative;
        }
        .bar-fill {
            height: 100%;
            transition: width 0.1s;
        }
        #brakeBarFill { background: yellow; }
        #boostBarFill { background: blue; }
        #powerUpMessage {
            position: absolute;
            top: 70px;
            left: 10px;
            color: yellow;
            font-family: Arial;
            font-size: 20px;
        }
        #crosshair {
            position: absolute;
            width: 20px;
            height: 20px;
            background: transparent;
            border: 2px solid cyan;
            border-radius: 50%;
            pointer-events: none;
            transform: translate(-50%, -50%);
        }
        #outerCrosshair {
            position: absolute;
            width: 30px;
            height: 30px;
            background: transparent;
            border: 2px solid rgba(0, 255, 255, 0.5);
            border-radius: 50%;
            pointer-events: none;
            transform: translate(-50%, -50%);
        }
        canvas { cursor: none; }
        .name-tag {
            position: absolute;
            color: white;
            font-family: Arial;
            font-size: 12px;
            background: rgba(0, 0, 0, 0.5);
            padding: 2px 5px;
            border-radius: 3px;
            pointer-events: none;
        }
        #gameOverMenu {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            font-family: Arial, sans-serif;
            z-index: 10;
        }
        #gameOverMenu h2 {
            font-size: 46px;
            margin-bottom: 20px;
            font-family: 'Bebas Neue', sans-serif;
        }
        #gameOverMenu button {
            padding: 10px 20px;
            font-size: 18px;
            cursor: pointer;
            
        }
    </style>
</head>
<body onload="document.body.focus();">
    <div id="mainMenu">
        <h1>Ultra Hyper Radical<br>Space Squadron</h1>

        <div class="credit">
            by <a href="https://x.com/AlexerSalcido" target="_blank" class="author">Alex Salcido</a> <span>+ Grok3 + 3JS</span>
        </div>

        <div class="description">A free-to-play space shooter. v1.0</div>
        
        <input type="text" id="playerNameInput" placeholder="Enter your name">
        <button onclick="startGame()">Start Game</button>
        <p id="nameError"></p>
        <p id="highScoreDisplay"></p>
        <div class="controls">
            <strong>Controls:</strong><br>
            Mouse and keyboard:<br>
            Use WASD to move the spaceship<br>
            Use C to do an Aileron Roll and activate shield<br>
            Spacebar to boost<br>
            Move the mouse to aim<br>
            Left click to shoot<br>
            Right click to brake
        </div>
        <div class="power-ups">
            <strong>Power Ups:</strong><br>
            Hearts recover life<br>
            Yellow orbs upgrade your weapons
        </div>
        <div class="sponsor">
            <a href="https://x.com/AlexerSalcido/" target="_blank">Contact me and Become a Sponsor</a>
        </div>
    </div>
    <div id="info" style="display: none;">
        <span id="scoreDisplay">Score: <span id="score">0</span></span>
        <br>
        <br>
        <div id="livesDisplay"></div>
    </div>
    
    <div id="bars" style="display: none;">
        <br>
        <br>
        <div class="bar-label">Brake</div>
        <div class="bar-container">
            <div id="brakeBarFill" class="bar-fill" style="width: 100%;"></div>
        </div>
        <div class="bar-label">Boost</div>
        <div class="bar-container">
            <div id="boostBarFill" class="bar-fill" style="width: 100%;"></div>
        </div>
    </div>
    <div id="powerUpMessage" style="display: none;"></div>
    <div id="crosshair" style="display: none;"></div>
    <div id="outerCrosshair" style="display: none;"></div>
    <div id="gameOverMenu">
        <h2>Game Over!</h2>
        <p>Final Score: <span id="finalScore"></span></p>
        <button onclick="restartGame()">Start Again</button>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    <script>

    const  scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer();
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);


    const textureLoader = new THREE.TextureLoader();
    textureLoader.load('textures/space_background.jpg', (texture) => {
        scene.background = texture;
    });


    const universeGeometry = new THREE.PlaneGeometry(100, 100); // Big plane
    const universeMaterial = new THREE.MeshBasicMaterial({
        map: textureLoader.load('textures/starfield.png'), // Starfield texture
        transparent: true, // Allow background to show through
        side: THREE.DoubleSide // Visible from both sides
    });
    const universePlane = new THREE.Mesh(universeGeometry, universeMaterial);
    universePlane.position.z = -50; // Behind everything
    scene.add(universePlane);


        let showEnemyTags = false;


        const trackLength = 1000;
        let trackPosition = 0;
        let baseTrackSpeed = 0.1;
        let currentTrackSpeed = baseTrackSpeed;


        const spaceshipGroup = new THREE.Group();
        const mainBodyGeometry = new THREE.ConeGeometry(0.5, 2, 3);
        const mainBodyMaterial = new THREE.MeshBasicMaterial({ color: 0xaaaaaa });
        const mainBody = new THREE.Mesh(mainBodyGeometry, mainBodyMaterial);
        mainBody.rotation.x = -Math.PI / 2; // Point forward (Z-axis)
        spaceshipGroup.add(mainBody);

        const wingGeometry = new THREE.BoxGeometry(2, 0.1, 0.5);
        const wingMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
        const leftWing = new THREE.Mesh(wingGeometry, wingMaterial);
        const rightWing = new THREE.Mesh(wingGeometry, wingMaterial);
        leftWing.position.set(-1.5, 0, 0);
        rightWing.position.set(1.5, 0, 0);
        leftWing.rotation.z = Math.PI / 4;
        rightWing.rotation.z = -Math.PI / 4;
        spaceshipGroup.add(leftWing, rightWing);

        const cockpitGeometry = new THREE.BoxGeometry(0.3, 0.2, 0.5);
        const cockpitMaterial = new THREE.MeshBasicMaterial({ color: 0x0000ff });
        const cockpit = new THREE.Mesh(cockpitGeometry, cockpitMaterial);
        cockpit.position.set(0, 0.3, -0.5);
        spaceshipGroup.add(cockpit);


        scene.add(spaceshipGroup);
        spaceshipGroup.position.z = -5;


        let leftTrail = null, rightTrail = null;
        function createTrails() {
            const trailMaterial = new THREE.LineBasicMaterial({ color: 0xffff00 });
            const trailGeometry = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, 2)]);
            leftTrail = new THREE.Line(trailGeometry, trailMaterial);
            rightTrail = new THREE.Line(trailGeometry, trailMaterial);
            leftTrail.position.set(-1.5, 0, 0);
            rightTrail.position.set(1.5, 0, 0);
            leftTrail.visible = false;
            rightTrail.visible = false;
            spaceshipGroup.add(leftTrail);
            spaceshipGroup.add(rightTrail);
        }
        createTrails();


        camera.position.set(0, 2, 5);
        camera.lookAt(0, 0, -100);


        let shakeTimer = 0;
        let shakeIntensity = 0;
        

        let boostShakeTimer = 0;
        let boostShakeIntensity = 0;


        const firstZoneLimit = 5;
        const secondZoneLimit = 9;


        let score = 0;
        let lives = 3;
        let gameOver = false;
        let bossSpawned = false;
        let justRestarted = false; // New flag to prevent immediate boss spawn after restart
        let invincibilityTimer = 0;
        let doubleShotActive = false;
        let doubleShotTimer = 0;
        let playerName = '';
        let highScore = localStorage.getItem('highScore') || 0;


        let brakeBar = 100;
        let boostBar = 100;
        let isBraking = false;
        let isBoosting = false;
        let brakeRegenDelay = 0;
        let boostRegenDelay = 0;


        let rollActive = false;
        let rollCooldown = 0;
        let rollAngle = 0;
        let rollDirection = 1;

        const projectiles = [];
        const enemyProjectiles = [];
        const explosionParticles = [];
        const enemies = [];
        const obstacles = [];
        const powerUps = [];
        const mountains = [];
        const billboards = [];
        const sideShips = [];


        let bossHitTimer = 0;
        let bossHitCount = 0;
        const bossOriginalColor = 0x0000ff; // Original boss color
        const bossHitColor = 0xff0000; // Red when hit



        const enemyDestroySound = new Audio('');
        const playerHitSound = new Audio('');


        const powerUpSound = new Audio(''); // Power-up pickup
        const playerDestroySound = new Audio(''); // Player destroyed
        const shootSound = new Audio(''); // Shooting
        const enemyAppearMusic = new Audio(''); // Enemy spawn music
        const bossDamageSound = new Audio(''); // Boss hit
        const bossDestroySound = new Audio(''); // Boss destroyed
        const backgroundMusic = new Audio(''); // Looping game music
        backgroundMusic.loop = true; // Loop the background track


        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let mouseWorldPos = new THREE.Vector3();


        const crosshair = document.getElementById('crosshair');
        const outerCrosshair = document.getElementById('outerCrosshair');
        let crosshairX = 0, crosshairY = 0;
        let outerCrosshairX = 0, outerCrosshairY = 0;

        document.addEventListener('mousemove', (event) => {
            crosshairX = event.clientX;
            crosshairY = event.clientY;
            crosshair.style.left = crosshairX + 'px';
            crosshair.style.top = crosshairY + 'px';
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const plane = new THREE.Plane(new THREE.Vector3(0, 0, 1), -trackPosition - 50);
            raycaster.ray.intersectPlane(plane, mouseWorldPos);
        });
        


        function updateOuterCrosshair() {
            outerCrosshairX += (crosshairX - outerCrosshairX) * 0.3;
            outerCrosshairY += (crosshairY - outerCrosshairY) * 0.4;
            outerCrosshair.style.left = outerCrosshairX + 'px';
            outerCrosshair.style.top = outerCrosshairY + 'px';
        }


        const keys = { w: false, a: false, s: false, d: false, space: false, q: false, e: false, c: false };
        document.addEventListener('keydown', (event) => {
            if (event.key === 'w') keys.w = true;
            if (event.key === 'a') keys.a = true;
            if (event.key === 's') keys.s = true;
            if (event.key === 'd') keys.d = true;
            if (event.key === ' ') keys.space = true;
            if (event.key === 'q') keys.q = true;
            if (event.key === 'e') keys.e = true;
            if (event.key === 'c') keys.c = true;
        });
        document.addEventListener('keyup', (event) => {
            if (event.key === 'w') keys.w = false;
            if (event.key === 'a') keys.a = false;
            if (event.key === 's') keys.s = false;
            if (event.key === 'd') keys.d = false;
            if (event.key === ' ') keys.space = false;
            if (event.key === 'q') keys.q = false;
            if (event.key === 'e') keys.e = false;
            if (event.key === 'c') keys.c = false;
        });


        let targetPitch = 0;
        let targetYaw = 0;
        let currentPitch = 0;
        let currentYaw = 0;
        let movementPitch = 0;
        let movementRoll = 0;
        let targetMovementPitch = 0;
        let targetMovementRoll = 0;


        let billboardTimer = 0; // Tracks time since last spawn
        let billboardCount = 0; // Tracks how many pairs spawned
        const maxBillboards = 10; // Still 10 pairs (20 total)


        const normalSpeed = 0.2;
        const quickSpeed = 0.4;
        const maxAngleNormal = Math.PI / 4;
        const maxAngleQuick = Math.PI / 2;


        document.addEventListener('contextmenu', (event) => event.preventDefault());
        document.addEventListener('mousedown', (event) => {
            if (event.button === 2) isBraking = true;
            if (event.button === 0 && !gameOver) {
                

                raycaster.setFromCamera(mouse, camera);
                const direction = raycaster.ray.direction.clone().normalize();
                const createProjectile = (offsetX = 0) => {
                    const projectileGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                    const projectileMaterial = new THREE.MeshBasicMaterial({ color: doubleShotActive ? 0x0000ff : 0xff0000 });
                    const projectile = new THREE.Mesh(projectileGeometry, projectileMaterial);
                    projectile.position.copy(spaceshipGroup.position);
                    projectile.position.z -= 1;
                    projectile.position.x += offsetX;
                    projectile.userData.direction = direction.clone();
                    projectile.userData.velocity = 1.0;
                    scene.add(projectile);
                    projectiles.push(projectile);
                };
                shootSound.pause(); // Stop current playback
                shootSound.currentTime = 0; // Reset to start
                shootSound.play() // REVISAR - NO FUNCIONA COMPLETAMENTE
                createProjectile(0);
                if (doubleShotActive) createProjectile(0.5);
            }
        });
        document.addEventListener('mouseup', (event) => {
            if (event.button === 2) isBraking = false;
        });


        let holdTimer = null

        document.addEventListener('mousedown', (event) => {
            if (event.button !== 0 || gameOver) return; // Only left click, not during game over
            const mouse = new THREE.Vector2();
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(mouse, camera);

            const intersects = raycaster.intersectObjects(billboards);
            if (intersects.length > 0) {
                const clickedBillboard = intersects[0].object;
                if (holdTimer) clearTimeout(holdTimer); // Clear any old timer
                holdTimer = setTimeout(() => {
                    if (clickedBillboard.userData.url) {
                        window.open(clickedBillboard.userData.url, '_blank');
                    }
                    holdTimer = null; // Reset after firing
                }, 1000); // 1-second hold
            }
        });

        document.addEventListener('mouseup', (event) => {
            if (event.button === 0 && holdTimer) {
                clearTimeout(holdTimer); // Cancel if released before 1 second
                holdTimer = null;
            }
        });


        const mainMenu = document.getElementById('mainMenu');
        const playerNameInput = document.getElementById('playerNameInput');
        const nameError = document.getElementById('nameError');
        const highScoreDisplay = document.getElementById('highScoreDisplay');
        highScoreDisplay.textContent = `High Score: ${highScore} (by ${localStorage.getItem('highScoreName') || 'Unknown'})`;

        const badWords = ['badword1', 'badword2', 'badword3']; // Replace with actual list
        function checkName(name) {
            return badWords.some(word => name.toLowerCase().includes(word));
        }

        function startGame() {
            const name = playerNameInput.value.trim();
            if (!name) {
                nameError.textContent = 'Please enter a name.';
                return;
            }
            if (checkName(name)) {
                nameError.textContent = 'Name contains inappropriate words. Please change it.';
                return;
            }
            playerName = name;
            mainMenu.style.display = 'none';
            document.getElementById('info').style.display = 'block';
            document.getElementById('bars').style.display = 'block';
            document.getElementById('powerUpMessage').style.display = 'block';
            crosshair.style.display = 'block';
            outerCrosshair.style.display = 'block';
            gameOver = false;
            animate();



        }

        function restartGame() {
            document.getElementById('gameOverMenu').style.display = 'none';


            score = 0;
            lives = 3;
            trackPosition = 0;
            bossSpawned = false;
            justRestarted = true; // Set flag to prevent immediate boss spawn
            invincibilityTimer = 0;
            doubleShotActive = false;
            doubleShotTimer = 0;
            brakeBar = 100;
            boostBar = 100;
            rollActive = false;
            rollCooldown = 0;
            rollAngle = 0;
            shakeTimer = 0;
            shakeIntensity = 0;
            boostShakeTimer = 0;
            boostShakeIntensity = 0;
            gameOver = false; // Ensure gameOver is reset
            

            spaceshipGroup.position.set(0, 0, -5);
            spaceshipGroup.rotation.set(0, 0, 0);
            

            destroyAllTagsOnRestart();


            projectiles.forEach(projectile => scene.remove(projectile));
            projectiles.length = 0;
            explosionParticles.forEach(particle => scene.remove(particle));
            explosionParticles.length = 0;


            if (boss) {
                scene.remove(boss);
                boss = null;
                weakSpots = [];
            }


            const healthBar = document.getElementById('bossHealthBar');
            if (healthBar && healthBar.parentNode) document.body.removeChild(healthBar);
            const bossLabel = document.querySelector('div[style*="top: 35px"]'); // Matches the labelâ€™s inline style
            if (bossLabel && bossLabel.parentNode) document.body.removeChild(bossLabel);


            currentPitch = 0;
            currentYaw = 0;
            movementPitch = 0;
            movementRoll = 0;
            targetMovementPitch = 0;
            targetMovementRoll = 0;


            updateUI();
            animate(); // Restart the animation loop
        }


        const groundGeometry = new THREE.PlaneGeometry(100, trackLength * 2);
        const groundMaterial = new THREE.MeshBasicMaterial({ color: 0x333333 });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.position.y = -15;
        scene.add(ground);



        function spawnBillboard() {

            const textureLoader = new THREE.TextureLoader();
            const billboardTexture = textureLoader.load('textures/billboard.png');


            const billboardGeometry = new THREE.BoxGeometry(10, 6, 0.2);
            const billboardMaterial = new THREE.MeshBasicMaterial({ 

                map: billboardTexture, // Use PNG texture
                side: THREE.DoubleSide // Visible from both sides
            
            
            });
            const billboard = new THREE.Mesh(billboardGeometry, billboardMaterial);

            billboard.userData = {url: 'https://x.com/AlexerSalcido/'}
            const side = Math.random() < 0.5 ? -20 : 20;
            billboard.position.set(
                side,
                5,
                -trackPosition - 50
            );
            scene.add(billboard);
            billboards.push(billboard);
            createNameTag(billboard, `Billboard ${billboards.length}`);
        }

        function spawnSideShip() {
            const shipGeometry = new THREE.BoxGeometry(3, 1, 5);
            const shipMaterial = new THREE.MeshBasicMaterial({ color: 0x5555ff });
            const ship = new THREE.Mesh(shipGeometry, shipMaterial);
            const side = Math.random() < 0.5 ? -30 : 30;
            ship.position.set(
                side,
                Math.random() * 10 - 5,
                -trackPosition - 50
            );
            scene.add(ship);
            sideShips.push(ship);
            createNameTag(ship, `Ship ${sideShips.length}`);
        }


        function spawnEnemy(type = 'default') {
            let enemyGeometry, enemyMaterial, enemy;
            if (type === 'purple') {
                enemy = createTurretEnemy();
                enemy.position.set(Math.random() * 20 - 10, Math.random() * 20 - 10, -trackPosition - 50);
                enemy.health = 1;
                enemy.userData.type = 'purple';
                if (showEnemyTags) createNameTag(enemy, `${type.charAt(0).toUpperCase() + type.slice(1)} ${enemies.length + 1}`);
            } else if (type === 'green') {
                enemy = createSpaceshipEnemy(0x00ff00);
                enemy.position.set(Math.random() * 20 - 10, Math.random() * 20 - 10, -trackPosition - 20);
                enemy.health = 1;
                enemy.userData.type = 'green';
                if (showEnemyTags) createNameTag(enemy, `${type.charAt(0).toUpperCase() + type.slice(1)} ${enemies.length + 1}`);
            } else if (type === 'pink') {
                enemy = createSpaceshipEnemy(0xff69b4);
                const side = Math.random() < 0.5 ? -15 : 15;
                enemy.position.set(side, Math.random() * 20 - 10, spaceshipGroup.position.z + 10);
                enemy.health = 1;
                enemy.userData.type = 'pink';
                enemy.userData.state = 'movingToFront';
                if (showEnemyTags) createNameTag(enemy, `${type.charAt(0).toUpperCase() + type.slice(1)} ${enemies.length + 1}`);
            } else if (type === 'orange') {
                enemy = createSpaceshipEnemy(0xffa500);
                enemy.position.set(Math.random() * 20 - 10, Math.random() * 20 - 10, -trackPosition - 50);
                enemy.health = 1;
                enemy.userData.type = 'orange';
                enemy.userData.angle = Math.random() * Math.PI * 2;
                if (showEnemyTags) createNameTag(enemy, `${type.charAt(0).toUpperCase() + type.slice(1)} ${enemies.length + 1}`);
            } else if (type === 'cyan') {
                enemy = createSpaceshipEnemy(0x00ffff);
                enemy.position.set(Math.random() * 20 - 10, Math.random() * 20 - 10, -trackPosition - 50);
                enemy.health = 1;
                enemy.userData.type = 'cyan';
                enemy.userData.angle = Math.random() * Math.PI * 2;
                if (showEnemyTags) createNameTag(enemy, `${type.charAt(0).toUpperCase() + type.slice(1)} ${enemies.length + 1}`);
            } else {
                enemy = createSpaceshipEnemy(0xff0000);
                enemy.position.set(Math.random() * 20 - 10, Math.random() * 20 - 10, -trackPosition - 50);
                enemy.health = 1;
                enemy.userData.type = 'default';
                if (showEnemyTags) createNameTag(enemy, `${type.charAt(0).toUpperCase() + type.slice(1)} ${enemies.length + 1}`);
            }
            scene.add(enemy);
            enemies.push(enemy);
        }


        function explodeEnemy(enemy) {
            for (let i = 0; i < 10; i++) {
                const particleGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                const particleMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
                const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                particle.position.copy(enemy.position);
                const velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 1,
                    (Math.random() - 0.5) * 1,
                    (Math.random() - 0.5) * 1
                ).normalize().multiplyScalar(Math.random() * 1);
                particle.userData.velocity = velocity;
                particle.userData.isCosmetic = true; // Mark as non-damaging
                scene.add(particle);
                explosionParticles.push(particle); // Use separate array
            }
        }


        


        function createSpaceshipEnemy(color) {
            const group = new THREE.Group();
            

            const bodyGeometry = new THREE.ConeGeometry(0.4, 1.5, 8);
            const bodyMaterial = new THREE.MeshBasicMaterial({ color });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.rotation.x = Math.PI; // Point forward
            group.add(body);


            const wingGeometry = new THREE.BoxGeometry(1.2, 0.1, 0.5);
            const wingMaterial = new THREE.MeshBasicMaterial({ color: 0xaaaaaa }); // Grey wings
            const leftWing = new THREE.Mesh(wingGeometry, wingMaterial);
            const rightWing = new THREE.Mesh(wingGeometry, wingMaterial);
            leftWing.position.set(-0.8, 0, 0);
            rightWing.position.set(0.8, 0, 0);
            leftWing.rotation.z = Math.PI / 6;
            rightWing.rotation.z = -Math.PI / 6;
            group.add(leftWing, rightWing);


            const cockpitGeometry = new THREE.SphereGeometry(0.2, 8, 8);
            const cockpitMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 }); // Black cockpit
            const cockpit = new THREE.Mesh(cockpitGeometry, cockpitMaterial);
            cockpit.position.set(0, 0.2, -0.5);
            group.add(cockpit);

            return group;
        }
                

        function createTurretEnemy() {
            const group = new THREE.Group();


            const baseGeometry = new THREE.CylinderGeometry(0.8, 0.8, 0.5, 16);
            const baseMaterial = new THREE.MeshBasicMaterial({ color: 0x800080 }); // Purple
            const base = new THREE.Mesh(baseGeometry, baseMaterial);
            group.add(base);


            const barrelGeometry = new THREE.BoxGeometry(0.2, 0.2, 1.5);
            const barrelMaterial = new THREE.MeshBasicMaterial({ color: 0x555555 }); // Dark grey
            const barrel = new THREE.Mesh(barrelGeometry, barrelMaterial);
            barrel.position.set(0, 0.4, 0.5); // Offset forward and up
            group.add(barrel);

            return group;
        }


        function createNameTag(object, name) {
            const div = document.createElement('div');
            div.className = 'name-tag';
            div.textContent = name;
            document.body.appendChild(div);
            object.userData.nameTag = div;
        }

        function updateNameTags() {
            [].forEach(collection => {
                collection.forEach(obj => {
                    const pos = new THREE.Vector3();
                    obj.getWorldPosition(pos);
                    const screenPos = pos.project(camera);
                    const x = (screenPos.x + 1) * window.innerWidth / 2;
                    const y = (-screenPos.y + 1) * window.innerHeight / 2;
                    obj.userData.nameTag.style.left = `${x}px`;
                    obj.userData.nameTag.style.top = `${y - 20}px`;
                    obj.userData.nameTag.style.display = (screenPos.z > 0 && screenPos.z < 1) ? 'block' : 'none';
                });
            });
        }


        function spawnObstacle() {
            const obstacleGeometry = new THREE.BoxGeometry(2, 5, 2);
            const obstacleMaterial = new THREE.MeshBasicMaterial({ color: 0x888888 });
            const obstacle = new THREE.Mesh(obstacleGeometry, obstacleMaterial);
            const spawnFromTop = Math.random() < 0.5;
            obstacle.position.set(
                Math.random() * 20 - 10,
                spawnFromTop ? 10 : -2.5,
                -trackPosition - 50
            );
            scene.add(obstacle);
            obstacles.push(obstacle);
            createNameTag(obstacle, `Obstacle ${obstacles.length}`);
        }


        function spawnPowerUp(type) {
            let powerUp;
            if (type === 'extraLife') {
                const heartShape = new THREE.Shape();
                heartShape.moveTo(0, 0);
                heartShape.quadraticCurveTo(0.5, 0.5, 1, 0);
                heartShape.quadraticCurveTo(1.5, -0.5, 0, -1);
                heartShape.quadraticCurveTo(-1.5, -0.5, -1, 0);
                heartShape.quadraticCurveTo(-0.5, 0.5, 0, 0);
                const extrudeSettings = { depth: 0.2, bevelEnabled: false };
                const heartGeometry = new THREE.ExtrudeGeometry(heartShape, extrudeSettings);
                const heartMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
                powerUp = new THREE.Mesh(heartGeometry, heartMaterial);
            } else {

                const prismGeometry = new THREE.CylinderGeometry(0.5, 0.5, 1, 3); // 3 sides = triangular prism
                const prismMaterial = new THREE.MeshBasicMaterial({ color: 0xffd700 }); // Gold color
                powerUp = new THREE.Mesh(prismGeometry, prismMaterial);
            }
            powerUp.position.set(Math.random() * 20 - 10, Math.random() * 20 - 10, -trackPosition - 50);
            powerUp.userData.type = type;
            scene.add(powerUp);
            powerUps.push(powerUp);
        }


        let boss = null;
        let weakSpots = [];

        function spawnBoss() {
            const group = new THREE.Group();


            const bodyGeometry = new THREE.BoxGeometry(3, 4, 2);
            const bodyMaterial = new THREE.MeshBasicMaterial({ color: bossOriginalColor });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            group.add(body);


            const armGeometry = new THREE.CylinderGeometry(0.5, 0.5, 3, 8);
            const armMaterial = new THREE.MeshBasicMaterial({ color: 0x666666 });
            const leftArm = new THREE.Mesh(armGeometry, armMaterial);
            const rightArm = new THREE.Mesh(armGeometry, armMaterial);
            leftArm.position.set(-2, 0, 0);
            rightArm.position.set(2, 0, 0);
            leftArm.rotation.z = Math.PI / 4;
            rightArm.rotation.z = -Math.PI / 4;
            group.add(leftArm, rightArm);


            const headGeometry = new THREE.SphereGeometry(1, 16, 16);
            const headMaterial = new THREE.MeshBasicMaterial({ color: 0x333333 });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.set(0, 2.5, 0);
            group.add(head);


            const eyeGeometry = new THREE.SphereGeometry(0.2, 8, 8);
            const eyeMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });
            const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            leftEye.position.set(-0.4, 2.7, 0.8);
            rightEye.position.set(0.4, 2.7, 0.8);
            group.add(leftEye, rightEye);

            group.position.set(0, 0, -trackPosition - 20);
            group.health = 10;
            if (showEnemyTags) createNameTag(group, "Zorgon the Devastator");
            scene.add(group);
            boss = group;
            bossSpawned = true;


            const weakSpotGeometry = new THREE.SphereGeometry(0.5, 8, 8);
            const weakSpotMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            for (let i = 0; i < 3; i++) {
                const weakSpot = new THREE.Mesh(weakSpotGeometry, weakSpotMaterial);
                if (i === 0) weakSpot.position.set(-2, -1, 0);
                else if (i === 1) weakSpot.position.set(2, -1, 0);
                else weakSpot.position.set(0, 3, 0);
                weakSpot.userData.isWeakSpot = true;
                group.add(weakSpot);
                weakSpots.push(weakSpot);
            }


            const healthBar = document.createElement('div');
            healthBar.id = 'bossHealthBar';
            healthBar.style.position = 'absolute';
            healthBar.style.top = '10px';
            healthBar.style.left = '50%';
            healthBar.style.transform = 'translateX(-50%)';
            healthBar.style.width = '200px';
            healthBar.style.height = '20px';
            healthBar.style.background = '#333';
            healthBar.style.border = '1px solid #fff';
            const fill = document.createElement('div');
            fill.style.width = '100%';
            fill.style.height = '100%';
            fill.style.background = 'red';
            healthBar.appendChild(fill);
            const label = document.createElement('div');
            label.textContent = 'Zorgon the Devastator';
            label.style.color = 'white';
            label.style.textAlign = 'center';
            label.style.fontFamily = 'Roboto, sans-serif';
            document.body.appendChild(healthBar);
            document.body.appendChild(label);
            label.style.position = 'absolute';
            label.style.top = '35px';
            label.style.left = '50%';
            label.style.transform = 'translateX(-50%)';
        }

        function explodeBoss() {
            for (let i = 0; i < 20; i++) {
                const particle = new THREE.Mesh(
                    new THREE.SphereGeometry(0.2, 8, 8),
                    new THREE.MeshBasicMaterial({ color: 0xff0000 })
                );
                particle.position.copy(boss.position);
                const velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 2,
                    (Math.random() - 0.5) * 2,
                    (Math.random() - 0.5) * 2
                ).normalize().multiplyScalar(Math.random() * 2);
                particle.userData.velocity = velocity;
                scene.add(particle);
                projectiles.push(particle);
            }
            bossDestroySound.play();
            scene.remove(boss);
            document.body.removeChild(document.getElementById('bossHealthBar'));
            document.body.removeChild(document.querySelector('div[style*="top: 35px"]')); // Remove label
            boss = null;
            weakSpots = [];
            score += 100;
            setTimeout(() => {
                document.getElementById('gameOverMenu').style.display = 'flex';
                document.getElementById('gameOverMenu').querySelector('h2').textContent = "Level Completed!";
                document.getElementById('finalScore').textContent = score;
                if (score > highScore) {
                    highScore = score;
                    localStorage.setItem('highScore', highScore);
                    localStorage.setItem('highScoreName', playerName);
                }
            }, 5000); // 5-second delay
        }


        function enemyShoot(enemy) {
            const projectileGeometry = new THREE.SphereGeometry(0.1, 8, 8);
            const projectileMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });
            const projectile = new THREE.Mesh(projectileGeometry, projectileMaterial);
            projectile.position.copy(enemy.position);

            if (enemy.userData.type === 'purple') {
                const directionToPlayer = spaceshipGroup.position.clone().sub(enemy.position).normalize();
                projectile.userData.direction = directionToPlayer;
            } else {
                projectile.userData.direction = new THREE.Vector3(0, 0, 1);
            }

            projectile.userData.velocity = 0.3;
            scene.add(projectile);
            enemyProjectiles.push(projectile);
        }


        function triggerCameraShake(intensity, duration) {
            shakeIntensity = intensity;
            shakeTimer = duration;
        }


        function displayPowerUpMessage(message) {
            const messageDiv = document.getElementById('powerUpMessage');
            messageDiv.textContent = message;
            setTimeout(() => {
                messageDiv.textContent = '';
            }, 3000);
        }


        function updateUI() {
            document.getElementById('score').textContent = score;
            const livesDisplay = document.getElementById('livesDisplay');
            livesDisplay.innerHTML = '';
            for (let i = 0; i < lives; i++) {
                const heart = document.createElement('div');
                heart.className = 'heart';
                livesDisplay.appendChild(heart);
            }
            document.getElementById('brakeBarFill').style.width = `${Math.floor(brakeBar)}%`;
            document.getElementById('boostBarFill').style.width = `${Math.floor(boostBar)}%`;
        }


        function checkCollisions() {
            projectiles.forEach((projectile, pIndex) => {
                if (projectile.userData.isCosmetic) return; // Skip explosion particles
                enemies.forEach((enemy, eIndex) => {
                    const distance = projectile.position.distanceTo(enemy.position);
                    if (distance < 3) {
                        enemy.health -= 1;
                        if (enemy.health <= 0) {

                            scene.remove(enemy);
                            document.body.removeChild(enemy.userData.nameTag);
                            enemies.splice(eIndex, 1);
                            score += 10;
                            enemyDestroySound.play();
                            triggerCameraShake(0.1, 0.2);
                        }
                        scene.remove(projectile);
                        projectiles.splice(pIndex, 1);
                    }
                });

                if (boss) {
                    const distanceToBoss = projectile.position.distanceTo(boss.position);
                    let hitWeakSpot = false;
                    weakSpots.forEach((weakSpot, wIndex) => {
                        const worldPos = weakSpot.getWorldPosition(new THREE.Vector3());
                        const distanceToWeakSpot = projectile.position.distanceTo(worldPos);
                        if (distanceToWeakSpot < 0.6) {
                            boss.health -= 2;
                            hitWeakSpot = true;
                            bossHitTimer = 0.5;
                            bossHitCount = 0;
                            boss.material.color.setHex(bossHitColor);
                            scene.remove(projectile);
                            projectiles.splice(pIndex, 1);
                            enemyDestroySound.play();
                            triggerCameraShake(0.1, 0.2);
                        }
                    });
                    if (!hitWeakSpot && distanceToBoss < 3) {
                        boss.health -= 1;
                        bossHitTimer = 0.5;
                        bossHitCount = 0;
                        boss.material.color.setHex(bossHitColor);
                        scene.remove(projectile);
                        projectiles.splice(pIndex, 1);
                        enemyDestroySound.play();
                        triggerCameraShake(0.1, 0.2);
                    }
                    if (boss.health <= 0) explodeBoss();
                }
            });

            if (invincibilityTimer <= 0) {
                enemyProjectiles.forEach((projectile, pIndex) => {
                    const distance = projectile.position.distanceTo(spaceshipGroup.position);
                    if (distance < 1) {
                        lives -= 1;
                        invincibilityTimer = 3;
                        doubleShotActive = false;
                        scene.remove(projectile);
                        enemyProjectiles.splice(pIndex, 1);
                        playerHitSound.play();
                        triggerCameraShake(0.3, 0.5);
                        if (lives <= 0) {
                            gameOver = true;
                            document.getElementById('finalScore').textContent = score;
                            document.getElementById('gameOverMenu').style.display = 'flex';
                            if (score > highScore) {
                                highScore = score;
                                localStorage.setItem('highScore', highScore);
                                localStorage.setItem('highScoreName', playerName);
                            }
                        }
                    }
                });

                obstacles.forEach((obstacle) => {
                    const distance = spaceshipGroup.position.distanceTo(obstacle.position);
                    if (distance < 2) {
                        lives -= 1;
                        invincibilityTimer = 3;
                        doubleShotActive = false;
                        playerHitSound.play();
                        triggerCameraShake(0.3, 0.5);
                        if (lives <= 0) {
                            gameOver = true;
                            document.getElementById('finalScore').textContent = score;
                            document.getElementById('gameOverMenu').style.display = 'flex';
                            if (score > highScore) {
                                highScore = score;
                                localStorage.setItem('highScore', highScore);
                                localStorage.setItem('highScoreName', playerName);
                            }
                        }
                    }
                });


                if (spaceshipGroup.position.y < -14) {
                    lives -= 1;
                    invincibilityTimer = 3;
                    doubleShotActive = false;
                    playerHitSound.play();
                    triggerCameraShake(0.3, 0.5);
                    spaceshipGroup.position.y = -14;
                    if (lives <= 0) {
                        gameOver = true;
                        document.getElementById('finalScore').textContent = score;
                        document.getElementById('gameOverMenu').style.display = 'flex';
                        if (score > highScore) {
                            highScore = score;
                            localStorage.setItem('highScore', highScore);
                            localStorage.setItem('highScoreName', playerName);
                        }
                    }
                }


                enemies.forEach((enemy, eIndex) => {
                    const distance = spaceshipGroup.position.distanceTo(enemy.position);
                    if (distance < 1) {
                        lives -= 1;
                        invincibilityTimer = 3;
                        doubleShotActive = false;

                        scene.remove(enemy);
                        enemies.splice(eIndex, 1);
                        if (enemy.userData.nameTag) document.body.removeChild(enemy.userData.nameTag);
                        playerHitSound.play();
                        triggerCameraShake(0.3, 0.5);
                        if (lives <= 0) {
                            gameOver = true;

                            document.getElementById('finalScore').textContent = score;
                                document.getElementById('gameOverMenu').style.display = 'flex';
                                if (score > highScore) {
                                    highScore = score;
                                    localStorage.setItem('highScore', highScore);
                                    localStorage.setItem('highScoreName', playerName);
                                }
                        }
                    }
                });
            }

            powerUps.forEach((powerUp, pIndex) => {
                const distance = spaceshipGroup.position.distanceTo(powerUp.position);
                if (distance < 2) {
                    if (powerUp.userData.type === 'extraLife') {
                        if (lives < 3) {
                        lives += 1;
                        displayPowerUpMessage('Extra Life!');
                        } else if (lives < 6) {
                            lives += 1;
                            displayPowerUpMessage('Bonus Life! Max 6');
                        } else {
                            displayPowerUpMessage('Max Lives Reached!');
                        }
                    } else if (powerUp.userData.type === 'doubleShot') {
                        doubleShotActive = true;
                        displayPowerUpMessage('Double Laser!');
                    }
                    powerUpSound.play();
                    scene.remove(powerUp);
                    powerUps.splice(pIndex, 1);
                }
            });
        }



        function explodePlayer() {
            for (let i = 0; i < 15; i++) {
                const particle = new THREE.Mesh(
                    new THREE.SphereGeometry(0.15, 8, 8),
                    new THREE.MeshBasicMaterial({ color: 0xffff00 })
                );
                particle.position.copy(spaceshipGroup.position);
                const velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 1.5,
                    (Math.random() - 0.5) * 1.5,
                    (Math.random() - 0.5) * 1.5
                ).normalize().multiplyScalar(Math.random() * 1.5);
                particle.userData.velocity = velocity;
                scene.add(particle);
                projectiles.push(particle);
            }
            playerDestroySound.play();
            spaceshipGroup.visible = false; // Hide ship during explosion
        }

        


        function despawnEnemiesOutOfBounds(restart) {
            if (restart) {

                while (enemies.length > 0) {
                    const enemy = enemies[0];
                    scene.remove(enemy);
                    if (enemy.userData.nameTag) document.body.removeChild(enemy.userData.nameTag);
                    enemies.splice(0, 1);
                }
            } else {

                let i = enemies.length;
                while (i--) {
                    const enemy = enemies[i];
                    if (
                        enemy.position.z > spaceshipGroup.position.z + 10 ||
                        Math.abs(enemy.position.x - spaceshipGroup.position.x) > 20 ||
                        Math.abs(enemy.position.y - spaceshipGroup.position.y) > 20
                    ) {
                        scene.remove(enemy);
                        if (enemy.userData.nameTag) document.body.removeChild(enemy.userData.nameTag);
                        enemies.splice(i, 1);
                    }
                }
            }
        }





        function destroyAllTagsOnRestart() {

            function cleanCollection(collection, collectionName) {
                console.log(`Cleaning collection: ${collectionName}, Initial length: ${collection.length}`);
                let index = collection.length;
                while (index--) {
                    const item = collection[index];
                    try {

                        scene.remove(item);

                        if (item.userData && item.userData.nameTag && item.userData.nameTag.parentNode) {
                            document.body.removeChild(item.userData.nameTag);
                        }
                    } catch (error) {
                        console.error(`Error cleaning item in ${collectionName}:`, error);
                    }

                    collection.splice(index, 1);
                }
                console.log(`After cleaning ${collectionName}, length: ${collection.length}`);
            }
            

            cleanCollection(enemies, "enemies");
            cleanCollection(mountains, "mountains");
            cleanCollection(billboards, "billboards");
            cleanCollection(sideShips, "sideShips");
            cleanCollection(obstacles, "obstacles");
            cleanCollection(powerUps, "powerUps");
        }


        function animate() {
            if (gameOver) return;

            requestAnimationFrame(animate);


        universeMaterial.map.offset.x += 0.0005; // Horizontal drift
        universeMaterial.map.offset.y += 0.0002; // Vertical drift


            currentTrackSpeed = baseTrackSpeed;
            if (isBraking && brakeBar > 0) {
                currentTrackSpeed *= 0.5;
                brakeBar = Math.max(0, brakeBar - 1);
                brakeRegenDelay = brakeBar === 0 ? 2 : 0;
            } else if ((keys.space && boostBar > 0) || rollActive) {
                currentTrackSpeed *= 2;
                boostBar = Math.max(0, boostBar - 1);
                boostRegenDelay = boostBar === 0 ? 2 : 0;
                leftTrail.visible = true;
                rightTrail.visible = true;

                boostShakeTimer = 0.1;
                boostShakeIntensity = 0.05;
            } else {
                leftTrail.visible = false;
                rightTrail.visible = false;
                boostShakeTimer = 0;
                boostShakeIntensity = 0;
            }


            if (!isBraking) {
                if (brakeRegenDelay > 0) brakeRegenDelay -= 1 / 60;
                else brakeBar = Math.min(100, brakeBar + 0.5);
            }
            if (!keys.space) {
                if (boostRegenDelay > 0) boostRegenDelay -= 1 / 60;
                else boostBar = Math.min(100, boostBar + 0.5);
            }


            if (keys.c && !rollActive && rollCooldown <= 0) {
                rollActive = true;
                rollAngle = 0;
                invincibilityTimer = 2;
                rollCooldown = 2;
                if (keys.a || keys.q) rollDirection = 1;
                else if (keys.d || keys.e) rollDirection = -1;
                else rollDirection = 1;
                leftTrail.visible = true;
                rightTrail.visible = true;
            }
            if (rollActive) {
                rollAngle += 0.3 * rollDirection;
                spaceshipGroup.rotation.z = movementRoll + Math.sin(rollAngle) * Math.PI;

                if (rollAngle >= 4 * Math.PI || rollAngle <= -4 * Math.PI) {
                    rollActive = false;
                    rollAngle = 0;
                    rollDirection = 1; // Reset direction
                    spaceshipGroup.rotation.z = movementRoll; // Reset rotation to base state
                    leftTrail.visible = false;
                    rightTrail.visible = false;
                }
            }
            if (rollCooldown > 0) rollCooldown -= 1 / 60;


            trackPosition += currentTrackSpeed;
            spaceshipGroup.position.z = -trackPosition;


            if (boostShakeTimer > 0) {
                boostShakeTimer -= 1 / 60;
                const shakeOffset = new THREE.Vector3(
                    (Math.random() - 0.5) * boostShakeIntensity,
                    (Math.random() - 0.5) * boostShakeIntensity,
                    0 // No shake on Z axis to avoid affecting movement
                );
                spaceshipGroup.position.add(shakeOffset);
            }


            const maxX = 20 - 0.25;
            const minX = -20 + 0.25;
            const maxY = 20 - 0.25;
            const minY = -20 + 0.25;

            if (keys.q && spaceshipGroup.position.x > minX) {
                spaceshipGroup.position.x -= quickSpeed;
            } else if (keys.a && spaceshipGroup.position.x > minX) {
                spaceshipGroup.position.x -= normalSpeed;
            }
            if (keys.e && spaceshipGroup.position.x < maxX) {
                spaceshipGroup.position.x += quickSpeed;
            } else if (keys.d && spaceshipGroup.position.x < maxX) {
                spaceshipGroup.position.x += normalSpeed;
            }
            if (keys.w && spaceshipGroup.position.y < maxY) spaceshipGroup.position.y += normalSpeed;
            if (keys.s && spaceshipGroup.position.y > minY) spaceshipGroup.position.y -= normalSpeed;


            targetMovementPitch = 0;
            targetMovementRoll = 0;

            if (keys.w) {
                targetMovementPitch = maxAngleNormal;
            } else if (keys.s) {
                targetMovementPitch = -maxAngleNormal;
            }

            if (keys.q) {
                targetMovementRoll = maxAngleQuick;
            } else if (keys.e) {
                targetMovementRoll = -maxAngleQuick;
            } else if (keys.a) {
                targetMovementRoll = maxAngleNormal;
            } else if (keys.d) {
                targetMovementRoll = -maxAngleNormal;
            }

            movementPitch += (targetMovementPitch - movementPitch) * 0.1;
            movementRoll += (targetMovementRoll - movementRoll) * 0.1;

            if (mouseWorldPos) {
                const directionToCrosshair = mouseWorldPos.clone().sub(spaceshipGroup.position).normalize();
                targetYaw = Math.atan2(directionToCrosshair.x, directionToCrosshair.z);
                targetPitch = Math.asin(directionToCrosshair.y);

                currentPitch += (targetPitch + movementPitch - currentPitch) * 0.1;
                currentYaw += (targetYaw - currentYaw) * 0.1;
                if (!rollActive) {
                    spaceshipGroup.rotation.x = currentPitch;
                    spaceshipGroup.rotation.y = currentYaw;
                    spaceshipGroup.rotation.z = movementRoll;
                }
            }


            const distanceFromCenter = Math.max(Math.abs(spaceshipGroup.position.x), Math.abs(spaceshipGroup.position.y));
            let targetCameraPos = new THREE.Vector3(0, 2, spaceshipGroup.position.z + 5);

            if (distanceFromCenter < firstZoneLimit) {
                targetCameraPos.set(0, 2, spaceshipGroup.position.z + 5);
            } else if (distanceFromCenter >= firstZoneLimit && distanceFromCenter <= secondZoneLimit) {
                targetCameraPos.set(
                    spaceshipGroup.position.x * 0.2,
                    spaceshipGroup.position.y * 0.2 + 2,
                    spaceshipGroup.position.z + 5
                );
            } else {
                const offsetFactor = 0.4;
                targetCameraPos.set(
                    spaceshipGroup.position.x * offsetFactor,
                    spaceshipGroup.position.y * offsetFactor + 2,
                    spaceshipGroup.position.z + 5
                );
            }

            camera.position.lerp(targetCameraPos, 0.1);
            camera.lookAt(camera.position.x, camera.position.y, camera.position.z - 100);


            if (shakeTimer > 0) {
                shakeTimer -= 1 / 60;
                const shakeOffset = new THREE.Vector3(
                    (Math.random() - 0.5) * shakeIntensity,
                    (Math.random() - 0.5) * shakeIntensity,
                    (Math.random() - 0.5) * shakeIntensity
                );
                camera.position.add(shakeOffset);
            } else {
                shakeIntensity = 0;
            }


            const maxEnemies = 10;
            if (enemies.length < maxEnemies && Math.random() < 0.02 && trackPosition < trackLength - 100) {
                const type = Math.random();
                if (type < 0.2) spawnEnemy('purple');
                else if (type < 0.4) spawnEnemy('green');
                else if (type < 0.6) spawnEnemy('pink');
                else if (type < 0.8) spawnEnemy('orange'); 
                else if (type < 0.9) spawnEnemy('cyan');// Add orange enemy
                else spawnEnemy('default');
            }

            if (Math.random() < 0.01 && trackPosition < trackLength - 100) spawnObstacle();
            if (Math.random() < 0.005 && trackPosition < trackLength - 100) {
                const type = Math.random() < 0.5 ? 'extraLife' : 'doubleShot';
                spawnPowerUp(type);
            }
            if (Math.random() < 0.005 && trackPosition < trackLength - 100) spawnBillboard();
            if (Math.random() < 0.005 && trackPosition < trackLength - 100) spawnSideShip();

            if (trackPosition >= trackLength - 100 && !bossSpawned && lives > 0) {spawnBoss()};

            if (justRestarted && trackPosition > 10) { // Small buffer to ensure game loop stabilizes
                            justRestarted = false;
                        }

            projectiles.forEach((projectile, index) => {
            if (projectile.userData.direction) {

                projectile.position.add(projectile.userData.direction.clone().multiplyScalar(projectile.userData.velocity));
            } else if (projectile.userData.velocity) {

                    projectile.position.add(projectile.userData.velocity.clone());
                }

                if (projectile.position.z < -trackPosition - 50 || Math.abs(projectile.position.x) > 50 || Math.abs(projectile.position.y) > 50) {
                    scene.remove(projectile);
                    projectiles.splice(index, 1);
                }
            });



            explosionParticles.forEach((particle, index) => {
                if (particle.userData.velocity) {
                    particle.position.add(particle.userData.velocity.clone());
                }
                if (particle.position.z < -trackPosition - 50 || Math.abs(particle.position.x) > 50 || Math.abs(particle.position.y) > 50) {
                    scene.remove(particle);
                    explosionParticles.splice(index, 1);
                }
            });




            enemies.forEach((enemy) => {
                if (enemy.userData.type === 'purple' && Math.random() < 0.005) {
                    enemyShoot(enemy);
                } else if (enemy.userData.type === 'green') {
                    const targetPos = spaceshipGroup.position.clone();
                    targetPos.z -= 20;
                    const directionToTarget = targetPos.sub(enemy.position).normalize();
                    const distanceToTarget = enemy.position.distanceTo(targetPos);
                    if (distanceToTarget > 1) {
                        enemy.position.add(directionToTarget.multiplyScalar(0.1));
                    }
                } else if (enemy.userData.type === 'pink') {
                    if (enemy.userData.state === 'movingToFront') {
                        enemy.position.z -= 0.5;
                        if (enemy.position.z < spaceshipGroup.position.z - 20) {
                            enemy.userData.state = 'inFront';
                            enemy.position.x = Math.random() * 20 - 10;
                            enemy.position.y = Math.random() * 20 - 10;
                        }
                    } else {
                        const targetPos = spaceshipGroup.position.clone();
                        targetPos.z -= 20;
                        const directionToTarget = targetPos.sub(enemy.position).normalize();
                        const distanceToTarget = enemy.position.distanceTo(targetPos);
                        if (distanceToTarget > 1) {
                            enemy.position.add(directionToTarget.multiplyScalar(0.1));
                        }
                    }
                } else if (enemy.userData.type === 'orange') {
                    const targetPos = spaceshipGroup.position.clone();
                    targetPos.z -= 20;
                    const directionToTarget = targetPos.sub(enemy.position).normalize();
                    const distanceToTarget = enemy.position.distanceTo(targetPos);
                    if (distanceToTarget > 1) {
                        enemy.position.add(directionToTarget.multiplyScalar(0.1));
                    }

                    if (Math.random() < 0.005) {
                        const directionToPlayer = spaceshipGroup.position.clone().sub(enemy.position).normalize();
                        const projectileGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                        const projectileMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });
                        const projectile = new THREE.Mesh(projectileGeometry, projectileMaterial);
                        projectile.position.copy(enemy.position);
                        projectile.userData.direction = directionToPlayer;
                        projectile.userData.velocity = 0.3;
                        scene.add(projectile);
                        enemyProjectiles.push(projectile);
                    }
                } else if (enemy.userData.type === 'cyan') {

                    const targetPos = spaceshipGroup.position.clone();
                    const directionToTarget = targetPos.sub(enemy.position).normalize();
                    const distanceToTarget = enemy.position.distanceTo(targetPos);
                    if (distanceToTarget > 1) {
                        enemy.position.add(directionToTarget.multiplyScalar(0.05)); // Slower speed
                    }
                } else if (Math.random() < 0.01) {
                    enemyShoot(enemy);
                }
            });



            despawnEnemiesOutOfBounds();


            enemyProjectiles.forEach((projectile, index) => {
                if (projectile.userData.direction) {
                    projectile.position.add(projectile.userData.direction.clone().multiplyScalar(projectile.userData.velocity));
                } else {
                    projectile.position.z += 0.3;
                }
                if (projectile.position.z > -trackPosition + 50) {
                    scene.remove(projectile);
                    enemyProjectiles.splice(index, 1);
                }
            });


            if (bossHitTimer > 0) {
                bossHitTimer -= 1 / 60;
                if (bossHitTimer <= 0) {
                    bossHitCount++;
                    if (bossHitCount < 2) {

                        boss.material.color.setHex(boss.material.color.getHex() === bossOriginalColor ? bossHitColor : bossOriginalColor);
                        bossHitTimer = 0.5;
                    } else {

                        boss.material.color.setHex(bossOriginalColor);
                        bossHitCount = 0;
                    }
                }
            }



            if (boss) {
                boss.position.z = spaceshipGroup.position.z - 20;
                boss.position.x = Math.sin(trackPosition * 0.1) * 5;
                boss.position.y = Math.sin(trackPosition * 0.5) * 3; // Up and down movement
                if (Math.random() < 0.05) {

                    const eyePositions = [
                        boss.children[3].getWorldPosition(new THREE.Vector3()), // Left eye
                        boss.children[4].getWorldPosition(new THREE.Vector3())  // Right eye
                    ];
                    eyePositions.forEach(pos => {
                        const projectile = new THREE.Mesh(
                            new THREE.SphereGeometry(0.1, 8, 8),
                            new THREE.MeshBasicMaterial({ color: 0xffff00 })
                        );
                        projectile.position.copy(pos);
                        const direction = spaceshipGroup.position.clone().sub(pos).normalize();
                        projectile.userData.direction = direction;
                        projectile.userData.velocity = 0.3;
                        scene.add(projectile);
                        enemyProjectiles.push(projectile);
                    });
                }

                const healthBar = document.getElementById('bossHealthBar');
                if (healthBar) {
                    const fill = healthBar.children[0];
                    fill.style.width = `${(boss.health / 10) * 100}%`;
                }
            }


            if (invincibilityTimer > 0) {
                invincibilityTimer -= 1 / 60;
                spaceshipGroup.children.forEach(child => child.material.color.setHex(0xffff00));
            } else {
                spaceshipGroup.children[0].material.color.setHex(0xaaaaaa);
                spaceshipGroup.children[1].material.color.setHex(0x00ff00);
                spaceshipGroup.children[2].material.color.setHex(0x00ff00);
                spaceshipGroup.children[3].material.color.setHex(0x0000ff);
            }


            mountains.forEach((mountain, index) => {
                if (mountain.position.z > spaceshipGroup.position.z + 10) {
                    scene.remove(mountain);
                    if (mountain.userData.nameTag) document.body.removeChild(mountain.userData.nameTag);
                    mountains.splice(index, 1);
                }
            });

            billboards.forEach((billboard, index) => {
                if (billboard.position.z > spaceshipGroup.position.z + 10) {
                    scene.remove(billboard);
                    if (billboard.userData.nameTag) document.body.removeChild(billboard.userData.nameTag);
                    billboards.splice(index, 1);
                }
            });

            sideShips.forEach((ship, index) => {
                if (ship.position.z > spaceshipGroup.position.z + 10) {
                    scene.remove(ship);
                    if (ship.userData.nameTag) document.body.removeChild(ship.userData.nameTag);
                    sideShips.splice(index, 1);
                }
            });

            obstacles.forEach((obstacle, index) => {
                if (obstacle.position.z > spaceshipGroup.position.z + 10) {
                    scene.remove(obstacle);
                    if (obstacle.userData.nameTag) document.body.removeChild(obstacle.userData.nameTag);
                    obstacles.splice(index, 1);
                }
});

            powerUps.forEach((powerUp, index) => {
                if (powerUp.position.z > spaceshipGroup.position.z + 10) {
                    scene.remove(powerUp);
                    powerUps.splice(index, 1);
                }
            });

            updateOuterCrosshair();


            updateNameTags();


            checkCollisions();


            updateUI();

            renderer.render(scene, camera);
        }


        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
